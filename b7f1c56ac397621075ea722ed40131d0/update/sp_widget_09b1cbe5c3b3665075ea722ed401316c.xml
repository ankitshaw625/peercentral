<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function ($scope, $timeout) {
  /* widget controller */
  var c = this;

  c.currentScale = 'total';
  c.selectedOccasions = [];
  c.timeframe = 'all';
  c.hiddenGroups = [];

  var networkInstance = null;
  var originalNodes = [];

  // This function runs automatically when the widget initializes
  c.$onInit = function () {
    c.loadGraphData();
  };

  c.loadGraphData = function () {
    // Set a flag to show the loading indicator
    c.isLoading = true;

    // Call the server to get the graph data
    console.log(c);

    c.server.get({
      action: 'get_graph_data',
      occasions: c.selectedOccasions,
      timeframe: c.timeframe
    }).then(function (response) {
      // Once the data comes back, store it
      c.data.nodes = response.data.nodes;
      c.data.edges = response.data.edges;
      c.data.legendData = response.data.legendData;

      originalNodes = c.data.nodes.map(n => ({ ...n }));

      // Turn off the loading indicator
      c.isLoading = false;

      // Now, initialize the graph (inside a $timeout to ensure the container is visible)
      $timeout(function () {
        initializeGraph();
      });
    });
  };

  c.updateScale = function (scale) {
    if (!networkInstance || !originalNodes.length) return;

    const currentView = saveView();
    const scaleBy = scale || c.currentScale;

    // First, update tooltips instantly (no need to animate text)
    const currentNodes = networkInstance.body.data.nodes;
    var targetValues = {};

    originalNodes.forEach(function (node) {
      var value, tooltip;

      if (scaleBy === 'sent') {
        value = node.sent || 0;
        tooltip = node.label + " - Recognitions Sent: " + (node.sent || 0);
      } else if (scaleBy === 'received') {
        value = node.received || 0;
        tooltip = node.label + " - Recognitions Received: " + (node.received || 0);
      } else {
        value = (node.sent || 0) + (node.received || 0);
        tooltip = node.label + " - Recognitions (Sent: " + (node.sent || 0) + ", Received: " + (node.received || 0) + ")";
      }

      // Update tooltip immediately
      currentNodes.update({
        id: node.id,
        title: tooltip
      });

      targetValues[node.id] = value;
    });

    // Animate size change over 600ms
    animateNodeSizes(targetValues, 600);

    if (currentView) {
      setTimeout(function () {
        restoreView(currentView);
      }, 650); // Slightly after animation ends
    }
  };

  $scope.$on('graph.scale.filter.updated', function (event, data) {
    c.updateScale(data.selected.value);
  });

  $scope.$on('graph.occasion.filter.updated', function (event, data) {
    c.selectedOccasions = data.selected.map((item) => item.value);
    c.loadGraphData();
  });

  $scope.$on('graph.timeframe.filter.updated', function (event, data) {
    c.timeframe = data.selected.value;
    c.loadGraphData();
  });


  c.isGroupHidden = function (groupName) {
    return c.hiddenGroups.includes(groupName);
  };

  c.toggleGroup = (groupName) => {
    // 1. Update the list of hidden groups based on the legend click
    if (c.isGroupHidden(groupName)) {
      c.hiddenGroups = c.hiddenGroups.filter(g => g !== groupName);
    } else {
      c.hiddenGroups.push(groupName);
    }

    const nodesDataset = networkInstance.body.data.nodes;
    const edgesDataset = networkInstance.body.data.edges;

    // 2. Determine which nodes should be hidden based on the legend
    const nodesToHideByGroup = new Set(
      originalNodes
        .filter(node => c.hiddenGroups.includes(node.group))
        .map(node => node.id)
    );

    // 3. Determine which nodes have no visible edges
    const visibleEdges = c.data.edges.filter(edge =>
      !nodesToHideByGroup.has(edge.from) && !nodesToHideByGroup.has(edge.to)
    );

    const nodesWithVisibleEdges = new Set();
    visibleEdges.forEach(edge => {
      nodesWithVisibleEdges.add(edge.from);
      nodesWithVisibleEdges.add(edge.to);
    });

    // 4. Create the final node update list
    const nodeUpdates = originalNodes.map(node => {
      const isHiddenByGroup = nodesToHideByGroup.has(node.id);
      const hasNoVisibleEdges = !nodesWithVisibleEdges.has(node.id);

      // Hide the node if it's in a hidden group OR if it has no more visible connections
      return {
        id: node.id,
        hidden: isHiddenByGroup || hasNoVisibleEdges
      };
    });

    // 5. Apply the updates
    nodesDataset.update(nodeUpdates);
  };


  c.hasActiveFilters = function () {
    return c.currentScale !== 'total' ||
      c.selectedOccasions.length > 0 ||
      c.timeframe !== 'all' || c.hiddenGroups.length > 0;
  };

  c.resetFilters = function () {
    // 1. Tell all listening child widgets to reset themselves
    $rootScope.$broadcast('filters.reset');

    c.currentScale = 'total';
    c.selectedOccasions = [];
    c.timeframe = 'all';
    c.hiddenGroups = [];

    c.loadGraphData();
  };

  c.getColorForGroup = function (groupName) {
    if (!networkInstance) {
      return '#cccccc'; // Default color if graph isn't ready
    }

    // This asks the vis.js instance for the color it generated for a group
    return networkInstance.groups.get(groupName).color.background;
  };

  function animateNodeSizes(targetValues, duration) {
    if (!networkInstance) return;

    const nodes = networkInstance.body.data.nodes;
    const startValues = {};
    const startTime = performance.now();

    originalNodes.forEach(node => {
      const current = nodes.get(node.id);
      startValues[node.id] = current?.value || 0;
    });

    function step(now) {
      const progress = Math.min((now - startTime) / duration, 1);

      originalNodes.forEach(node => {
        const start = startValues[node.id];
        const end = targetValues[node.id];
        const value = start + (end - start) * progress;

        nodes.update({ id: node.id, value });
      });

      if (progress < 1) requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  }


  function saveView() {
    if (!networkInstance) return null;
    return {
      position: networkInstance.getViewPosition(),
      scale: networkInstance.getScale()
    };
  }

  function restoreView(view) {
    if (!networkInstance || !view) return;

    networkInstance.moveTo({
      position: view.position,
      scale: view.scale,
      animation: false
    });
  }

  const groupColors = {
    // Core Blues
    'Development': '#005F9E',      // Strong Blue
    'Product Management': '#00A4E0',// Bright Cyan-Blue

    // Core Greens
    'Customer Support': '#00847B', // Teal
    'Sales': '#8BC53F',            // Lime Green

    // Accent & Neutral
    'HR': '#E04E39',               // Muted Red/Terracotta
    'IT': '#7E8C9A',               // Slate Gray
    'N/A': '#D1D7DD'               // Light Gray
  };

  const graphOptions = {

    nodes: {
      size: 15, // A good default size for both images and dots
      font: {
        size: 14,
        face: 'Source Sans Pro',
        color: '#333' // White text looks good inside the colored dots
      },
      borderWidth: 3,

      scaling: {
        min: 15,
        max: 40
      },
      shapeProperties: {
        interpolation: false
      }
    },

    edges: {
      scaling: { min: 0.4, max: 4 },
      color: { inherit: 'from' },
      smooth: { type: 'continuous' },
      arrows: { to: { enabled: true, scaleFactor: 0.5 } }
    },

    physics: {
      solver: 'barnesHut',

      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 100,
        avoidOverlap: 1.5
      },

      stabilization: { iterations: 2000 }
    },

    interaction: {
      tooltipDelay: 200,
      navigationButtons: true,
      hover: true
    },

    groups: {
      'Development': {
        color: {
          border: groupColors['Development'],
          background: groupColors['Development'],
          highlight: { border: '#003E6B', background: '#005F9E' },
          hover: { border: '#003E6B', background: '#005F9E' }
        }
      },
      'Product Management': {
        color: {
          border: groupColors['Product Management'],
          background: groupColors['Product Management'],
          highlight: { border: '#007BAA', background: '#00A4E0' },
          hover: { border: '#007BAA', background: '#00A4E0' }
        }
      },
      'Customer Support': {
        color: {
          border: groupColors['Customer Support'],
          background: groupColors['Customer Support'],
          highlight: { border: '#005851', background: '#00847B' },
          hover: { border: '#005851', background: '#00847B' }
        }
      },
      'Sales': {
        color: {
          border: groupColors['Sales'],
          background: groupColors['Sales'],
          highlight: { border: '#679A2B', background: '#8BC53F' },
          hover: { border: '#679A2B', background: '#8BC53F' }
        }
      },
      'HR': {
        color: {
          border: groupColors['HR'],
          background: groupColors['HR'],
          highlight: { border: '#B33E2C', background: '#E04E39' },
          hover: { border: '#B33E2C', background: '#E04E39' }
        }
      },
      'IT': {
        color: {
          border: groupColors['IT'],
          background: groupColors['IT'],
          highlight: { border: '#5A636C', background: '#7E8C9A' },
          hover: { border: '#5A636C', background: '#7E8C9A' }
        }
      },
      'N/A': {
        color: {
          border: groupColors['N/A'],
          background: groupColors['N/A'],
          highlight: { border: '#A9B1B8', background: '#D1D7DD' },
          hover: { border: '#A9B1B8', background: '#D1D7DD' }
        }
      },
    }

    // layout: { hierarchical: { enabled: true } }
  };

  function initializeGraph() {
    if (!c.data.nodes || c.data.nodes.length === 0) return;

    var processedNodes = c.data.nodes.map(function (node) {
      var newNode = { ...node };

      newNode.value = node.sent + node.received;

      newNode.title = node.label + ' - Recognitions (Sent: ' + node.sent + ', Received: ' + node.received + ')';


      if (node.userImage) {
        // If an image exists, use it
        newNode.shape = 'circularImage';
        newNode.image = node.userImage;
        // newNode.label = ''; // Hide the external label
      } else {
        // If no image, use initials inside the dot
        newNode.shape = 'dot';
        // newNode.label = node.initials; // Use initials as the label inside the node
      }

      return newNode;

    });

    var nodes = new vis.DataSet(processedNodes);
    var edges = new vis.DataSet(c.data.edges);

    var container = document.getElementById('recognition-graph-container');
    var data = { nodes, edges };


    networkInstance = new vis.Network(container, data, graphOptions);

    networkInstance.once("stabilizationIterationsDone", centerNetworkView);
  }

  function centerNetworkView() {
    const positions = networkInstance.getPositions();
    let sumX = 0, sumY = 0, count = 0;

    for (const id in positions) {
      sumX += positions[id].x;
      sumY += positions[id].y;
      count++;
    }

    const center = { x: sumX / count, y: sumY / count };

    networkInstance.moveTo({
      position: center,
      scale: 1,
      animation: {
        duration: 800,
        easingFunction: "easeOutCubic"
      }
    });
  }
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.network-container {
    background: #fff;
    margin: 0 0 15px 0;
}

.network-container .panel-heading {
    position: relative;
}

.network-graph-title {
    font-weight: bold;
    margin-top: 0;
    margin-bottom: 0;
    font-family: $now-sp-font-family-sans-serif;
    color: #eee;
    font-size: 1.5rem;
}

.refresh-icon {
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
}

.graph-container {
    height: 70vh; /* 60% of the viewport height */
    min-height: 400px; /* Ensure it doesn't get too small */
}

.graph-filter {
    padding: 12px 16px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    align-items: center;
    gap: 12px;
}

.legend-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    margin-left: auto;
}

.legend-header {
    width: 100%;
    font-size: 13px;
    font-weight: bold;
    color: #666;
    margin: 0 0 5px 0;
    padding: 0;
}

.legend-item {
    display: flex;
    align-items: center;
    font-size: 12px;
    cursor: pointer;
    transition: opacity 0.2s ease-in-out;
}

.legend-color-box {
    width: 12px;
    height: 12px;
    border: 1px solid #ccc;
    margin-right: 5px;
    border-radius: 2px;
}

.legend-item-hidden {
    opacity: 0.4;
    text-decoration: line-through;
    cursor: pointer;
}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>recognition_network_graph</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {  }]]></link>
        <name>Recognition Network Graph</name>
        <option_schema/>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  // We only generate the data if the client has requested it (for async loading).
  if (input && input.action === 'get_graph_data') {
    const occasionIds = input.occasions || [];
    const daysAgo = parseInt(input.timeframe || 0, 10);

    const graphData = new x_1794402_peerce_0.RecognitionDAO().getGraphData(occasionIds, daysAgo);
    data.nodes = graphData.nodes;
    data.edges = graphData.edges;

    data.legendData = graphData.groups;

    return;
  }

  data.nodeScalingFilterWidget = $sp.getWidget('single-select-filter', {
    title: 'Scale nodes by',
    eventName: 'graph.scale.filter.updated',
    choices: [
      { display: 'Total Recognitions', value: 'total' },
      { display: 'Sent Recognitions', value: 'sent' },
      { display: 'Received Recognitions', value: 'received' }
    ],

    initialSelection: 'total'
  });

  data.timeframeFilterWidget = $sp.getWidget(
    'single-select-filter',
    {
      title: 'Timeframe',
      eventName: 'graph.timeframe.filter.updated',
      choices: [
        { display: 'All Time', value: 'all' },
        { display: 'Last 90 days', value: '90' },
        { display: 'Last 30 days', value: '30' },
        { display: 'Last 7 days', value: '7' }
      ],

      initialSelection: 'all',
    }
  );

  const recognitionOccasions =
    new x_1794402_peerce_0.RecognitionUtils().getRecognitionOccasions();

  data.occasionFilterWidget = $sp.getWidget(
    'multi-select-slushbucket-filter',
    {
      title: 'Occasions',
      eventName: 'graph.occasion.filter.updated',
      choices: recognitionOccasions,
      initialSelection: '',
    }
  );

})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>09b1cbe5c3b3665075ea722ed401316c</sys_id>
        <sys_mod_count>236</sys_mod_count>
        <sys_name>Recognition Network Graph</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy/>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sp_widget_09b1cbe5c3b3665075ea722ed401316c</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-28 21:57:51</sys_updated_on>
        <template><![CDATA[<div class="panel panel-primary network-container">

  <div class="panel-heading">
    <h2 tabindex="0" class="network-graph-title panel-title"><i class="fa fa-share-alt" aria-hidden="true"></i>
      Recognition Network</h2>
    <span class="glyphicon glyphicon-refresh refresh-icon" ng-click="c.loadGraphData()"></span>
  </div>

  <div class="graph-filter">
    <div class="filter-wrapper">
      <sp-widget widget="c.data.nodeScalingFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.timeframeFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.occasionFilterWidget"></sp-widget>
    </div>

    <a href ng-click="c.resetFilters()" ng-show="c.hasActiveFilters()" class="reset-link" title="Reset filters">â†º</a>

    <div class="legend-container">
      <h4 class="legend-header">Departments</h4>
      <div ng-repeat="item in c.data.legendData" class="legend-item" ng-click="c.toggleGroup(item)"
        ng-class="{'legend-item-hidden': c.isGroupHidden(item)}">
        <span class="legend-color-box" ng-style="{'background-color': c.getColorForGroup(item)}"></span>
        {{item}}
      </div>
    </div>

  </div>

  <div ng-if="c.isLoading" class="text-center mt-10">
    <i class="fa fa-spinner fa-spin fa-2x"></i>
    <p>Loading graph data...</p>
  </div>

  <div ng-if="!c.isLoading" id="recognition-graph-container" class="graph-container">
  </div>
</div>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>09b1cbe5c3b3665075ea722ed401316c</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>81b10fe5c3b3665075ea722ed401319b</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-05 12:42:38</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
