<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function ($scope, $timeout) {
  /* widget controller */
  var c = this;

  c.currentScale = 'total';
  c.selectedOccasions = [];
  c.timeframe = 'all';
  c.hiddenGroups = [];
  c.selectedNode = null;
  c.showMyNetwork = false;

  var networkInstance = null;
  var originalNodes = [];

  // This function runs automatically when the widget initializes
  c.$onInit = function () {
    c.loadGraphData();
  };

  c.loadGraphData = function () {
    // Set a flag to show the loading indicator
    c.isLoading = true;

    // Call the server to get the graph data
    // console.log(c);

    c.server.get({
      action: 'get_graph_data',
      occasions: c.selectedOccasions,
      timeframe: c.timeframe
    }).then(function (response) {
      // Once the data comes back, store it
      c.data.nodes = response.data.nodes;
      c.data.edges = response.data.edges;
      c.data.legendData = response.data.legendData;

      originalNodes = c.data.nodes.map(n => ({ ...n }));

      c.computeRoleThresholds();

      // Turn off the loading indicator
      c.isLoading = false;

      // Now, initialize the graph (inside a $timeout to ensure the container is visible)
      $timeout(function () {
        initializeGraph();
      });
    }).catch(err => {
      console.error('Graph load failed:', error);
      c.isLoading = false;
    });
  };

  c.updateScale = function (scale) {
    if (!networkInstance || !originalNodes.length) return;

    const currentView = saveView();
    const scaleBy = scale || c.currentScale;

    // First, update tooltips instantly (no need to animate text)
    const currentNodes = networkInstance.body.data.nodes;
    var targetValues = {};

    originalNodes.forEach(function (node) {
      var value, tooltip;

      if (scaleBy === 'sent') {
        value = node.sent || 0;
        tooltip = node.label + " - Recognitions Sent: " + (node.sent || 0);
      } else if (scaleBy === 'received') {
        value = node.received || 0;
        tooltip = node.label + " - Recognitions Received: " + (node.received || 0);
      } else {
        value = (node.sent || 0) + (node.received || 0);
        tooltip = node.label + " - Recognitions (Sent: " + (node.sent || 0) + ", Received: " + (node.received || 0) + ")";
      }

      // Update tooltip immediately
      currentNodes.update({
        id: node.id,
        title: tooltip
      });

      targetValues[node.id] = value;
    });

    // Animate size change over 600ms
    animateNodeSizes(targetValues, 600);

    if (currentView) {
      setTimeout(function () {
        restoreView(currentView);
      }, 650); // Slightly after animation ends
    }
  };


  $scope.$on('graph.scale.filter.updated', function (event, data) {
    c.updateScale(data.selected.value);
  });

  $scope.$on('graph.occasion.filter.updated', function (event, data) {
    c.selectedOccasions = data.selected.map((item) => item.value);
    c.loadGraphData();
  });

  $scope.$on('graph.timeframe.filter.updated', function (event, data) {
    c.timeframe = data.selected.value;
    c.loadGraphData();
  });

  c.applyVisibilityFilters = function () {
    if (!networkInstance || !originalNodes.length) return;

    const nodesDataset = networkInstance.body.data.nodes;
    let nodesToHide = new Set();

    // 1. Hide by department groups
    const nodesToHideByGroup = new Set(
      originalNodes
        .filter(node => c.hiddenGroups.includes(node.group))
        .map(node => node.id)
    );
    nodesToHideByGroup.forEach(id => nodesToHide.add(id));

    // 2. If "My Network" is active, restrict to first-degree connections
    if (c.showMyNetwork) {
      const currentUser = c.data.currentUserId;
      const userInGraph = originalNodes.some(n => n.id === currentUser);

      if (userInGraph) {
        const connectedNodeIds = new Set([currentUser]); // include self
        c.data.edges.forEach(edge => {
          if (edge.from === currentUser || edge.to === currentUser) {
            connectedNodeIds.add(edge.from);
            connectedNodeIds.add(edge.to);
          }
        });

        // Hide anyone NOT in the connected set
        originalNodes.forEach(node => {
          if (!connectedNodeIds.has(node.id)) {
            nodesToHide.add(node.id);
          }
        });
      }
      // If user not in graph, all nodes will be hidden → acceptable
    }

    // 3. Hide nodes with no visible edges (your existing logic)
    const visibleEdges = c.data.edges.filter(edge =>
      !nodesToHide.has(edge.from) && !nodesToHide.has(edge.to)
    );

    const nodesWithVisibleEdges = new Set();
    visibleEdges.forEach(edge => {
      nodesWithVisibleEdges.add(edge.from);
      nodesWithVisibleEdges.add(edge.to);
    });

    // 4. Apply final visibility
    const nodeUpdates = originalNodes.map(node => ({
      id: node.id,
      hidden: nodesToHide.has(node.id) || !nodesWithVisibleEdges.has(node.id)
    }));

    nodesDataset.update(nodeUpdates);
  };

  c.isGroupHidden = function (groupName) {
    return c.hiddenGroups.includes(groupName);
  };

  // Updated toggleGroup
  c.toggleGroup = (groupName) => {
    if (c.isGroupHidden(groupName)) {
      c.hiddenGroups = c.hiddenGroups.filter(g => g !== groupName);
    } else {
      c.hiddenGroups.push(groupName);
    }

    c.applyVisibilityFilters(); // ← Use unified logic
  };

  // New toggleMyNetwork
  c.toggleMyNetwork = function () {
    c.showMyNetwork = !c.showMyNetwork;
    c.applyVisibilityFilters();
  };


  c.hasActiveFilters = function () {
    return c.currentScale !== 'total' ||
      c.selectedOccasions.length > 0 ||
      c.timeframe !== 'all' || c.hiddenGroups.length > 0 || c.showMyNetwork === true;
  };

  c.resetFilters = function () {
    // Tell all listening child widgets to reset themselves
    $rootScope.$broadcast('filters.reset');

    c.currentScale = 'total';
    c.selectedOccasions = [];
    c.timeframe = 'all';
    c.hiddenGroups = [];
    c.showMyNetwork = false;

    c.loadGraphData();
  };

  c.computeRoleThresholds = function () {
    if (!c.data.nodes || c.data.nodes.length === 0) {
      c.roleThresholds = { sent: 1, received: 1 };
      return;
    }

    const sentValues = c.data.nodes.map(n => n.sent).sort((a, b) => a - b);
    const receivedValues = c.data.nodes.map(n => n.received).sort((a, b) => a - b);

    function getPercentile(arr, p) {
      if (arr.length === 0) return 0;
      const index = Math.floor(p * (arr.length - 1));
      return arr[Math.max(0, index)];
    }

    // 75th percentile = top 25% contributors
    const sent75 = getPercentile(sentValues, 0.75);
    const received75 = getPercentile(receivedValues, 0.75);

    c.roleThresholds = {
      sent: Math.max(2, sent75),
      received: Math.max(2, received75)
    };

    console.log('sent values: ', sentValues);
    console.log('received values: ', receivedValues);
    console.log('thresholds: ', c.roleThresholds);

  };

  c.getRoleExplanation = function (node) {
    if (!node || !c.roleThresholds) return '';

    var sent = node.sent;
    var received = node.received;
    var sentThresh = c.roleThresholds.sent;
    var receivedThresh = c.roleThresholds.received;

    if (sent >= sentThresh && received >= receivedThresh) {
      return "You've sent recognition " + sent + " times and received it " + received + " times — placing you among the most connected contributors.";
    }

    if (received >= receivedThresh && sent < sentThresh) {
      return "You've been recognized " + received + " times (top contributors have at least " + receivedThresh + "), showing your impact is widely valued.";
    }

    if (sent >= sentThresh && received < receivedThresh) {
      return "You've sent recognition " + sent + " times (top contributors send at least " + sentThresh + "), actively uplifting your peers.";
    }

    if (sent === 0)
      return "You've received " + received + " recognition(s) — thank you for being part of our recognition culture!";

    if (received === 0)
      return "You've sent " + sent + " recognition(s) — thank you for uplifting your peers!";

    return "You've sent " + sent + " and received " + received + " recognition(s) — thank you for participating in our recognition culture!";
  };

  c.getColorForGroup = function (groupName) {
    if (!networkInstance) {
      return '#cccccc'; // Default color if graph isn't ready
    }

    // This asks the vis.js instance for the color it generated for a group
    return networkInstance.groups.get(groupName).color.background;
  };

  c.closeModal = function () {
    c.selectedNode = null;
  };

  function animateNodeSizes(targetValues, duration) {
    if (!networkInstance) return;

    const nodes = networkInstance.body.data.nodes;
    const startValues = {};
    const startTime = performance.now();

    originalNodes.forEach(node => {
      const current = nodes.get(node.id);
      startValues[node.id] = current?.value || 0;
    });

    function step(now) {
      const progress = Math.min((now - startTime) / duration, 1);

      originalNodes.forEach(node => {
        const start = startValues[node.id];
        const end = targetValues[node.id];
        const value = start + (end - start) * progress;

        nodes.update({ id: node.id, value });
      });

      if (progress < 1) requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  }


  function saveView() {
    if (!networkInstance) return null;
    return {
      position: networkInstance.getViewPosition(),
      scale: networkInstance.getScale()
    };
  }

  function restoreView(view) {
    if (!networkInstance || !view) return;

    networkInstance.moveTo({
      position: view.position,
      scale: view.scale,
      animation: false
    });
  }

  const groupColors = {
    // Core Blues
    'Development': '#005F9E',      // Strong Blue
    'Product Management': '#00A4E0',// Bright Cyan-Blue

    // Core Greens
    'Customer Support': '#00847B', // Teal
    'Sales': '#8BC53F',            // Lime Green

    // Accent & Neutral
    'HR': '#E04E39',               // Muted Red/Terracotta
    'IT': '#7E8C9A',               // Slate Gray
    'N/A': '#D1D7DD'               // Light Gray
  };

  const graphOptions = {

    nodes: {
      size: 15,
      font: {
        size: 14,
        face: 'Source Sans Pro',
        color: '#333'
      },

      borderWidth: 4,

      scaling: {
        min: 15,
        max: 40
      },
      shapeProperties: {
        interpolation: false
      }
    },

    edges: {
      scaling: { min: 0.4, max: 4 },
      color: { inherit: 'from' },
      smooth: { type: 'continuous' },
      arrows: { to: { enabled: true, scaleFactor: 0.5 } }
    },

    physics: {
      solver: 'barnesHut',

      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 100,
        avoidOverlap: 1.5
      },

      stabilization: { iterations: 2000 }
    },

    interaction: {
      tooltipDelay: 200,
      navigationButtons: true,
      hover: true
    },

    groups: {
      'Development': {
        color: {
          border: groupColors['Development'],
          background: groupColors['Development'],
          highlight: { border: '#003E6B', background: '#005F9E' },
          hover: { border: '#003E6B', background: '#005F9E' }
        }
      },
      'Product Management': {
        color: {
          border: groupColors['Product Management'],
          background: groupColors['Product Management'],
          highlight: { border: '#007BAA', background: '#00A4E0' },
          hover: { border: '#007BAA', background: '#00A4E0' }
        }
      },
      'Customer Support': {
        color: {
          border: groupColors['Customer Support'],
          background: groupColors['Customer Support'],
          highlight: { border: '#005851', background: '#00847B' },
          hover: { border: '#005851', background: '#00847B' }
        }
      },
      'Sales': {
        color: {
          border: groupColors['Sales'],
          background: groupColors['Sales'],
          highlight: { border: '#679A2B', background: '#8BC53F' },
          hover: { border: '#679A2B', background: '#8BC53F' }
        }
      },
      'HR': {
        color: {
          border: groupColors['HR'],
          background: groupColors['HR'],
          highlight: { border: '#B33E2C', background: '#E04E39' },
          hover: { border: '#B33E2C', background: '#E04E39' }
        }
      },
      'IT': {
        color: {
          border: groupColors['IT'],
          background: groupColors['IT'],
          highlight: { border: '#5A636C', background: '#7E8C9A' },
          hover: { border: '#5A636C', background: '#7E8C9A' }
        }
      },
      'N/A': {
        color: {
          border: groupColors['N/A'],
          background: groupColors['N/A'],
          highlight: { border: '#A9B1B8', background: '#D1D7DD' },
          hover: { border: '#A9B1B8', background: '#D1D7DD' }
        }
      },
    }

    // layout: { hierarchical: { enabled: true } }
  };

  function initializeGraph() {
    if (!c.data.nodes || c.data.nodes.length === 0) return;

    var processedNodes = c.data.nodes.map(function (node) {
      var newNode = { ...node };

      newNode.value = node.sent + node.received;

      newNode.title = node.label + ' - Recognitions (Sent: ' + node.sent + ', Received: ' + node.received + ')';


      if (node.userImage) {
        // If an image exists, use it
        newNode.shape = 'circularImage';
        newNode.image = node.userImage;
        // newNode.label = ''; // Hide the external label
      } else {
        // If no image, use initials inside the dot
        newNode.shape = 'dot';
        // newNode.label = node.initials; // Use initials as the label inside the node
      }

      return newNode;

    });

    var nodes = new vis.DataSet(processedNodes);
    var edges = new vis.DataSet(c.data.edges);

    var container = document.getElementById('recognition-graph-container');
    var data = { nodes, edges };


    networkInstance = new vis.Network(container, data, graphOptions);


    // Event listeners for network graph
    networkInstance.on('click', function (params) {
      // If the click was on the empty canvas (not a node), close the sidebar.
      if (params.nodes.length === 0) {
        c.closeModal();
        $scope.$applyAsync();
      }
    });

    networkInstance.on('oncontext', function (params) {
      // Prevent the default browser right-click menu
      params.event.preventDefault();

      const nodeId = networkInstance.getNodeAt(params.pointer.DOM);

      if (!nodeId) return;

      if (c.selectedNode && c.selectedNode.id === nodeId) return;

      // Find the basic node data immediately
      c.selectedNode = originalNodes.find(n => n.id === nodeId);

      // Fetch the detailed activity feed from the server
      if (c.selectedNode) {
        c.selectedNode.loadingDetails = true;
        c.server.get({
          action: 'get_recognition_details',
          userId: c.selectedNode.id
        }).then(function (response) {
          c.selectedNode.details = response.data.details;
          c.selectedNode.loadingDetails = false;
        });
      }

      $scope.$applyAsync();
    });


    networkInstance.once('stabilizationIterationsDone', centerNetworkView);
  }



  function centerNetworkView() {
    const positions = networkInstance.getPositions();
    let sumX = 0, sumY = 0, count = 0;

    for (const id in positions) {
      sumX += positions[id].x;
      sumY += positions[id].y;
      count++;
    }

    const center = { x: sumX / count, y: sumY / count };

    networkInstance.moveTo({
      position: center,
      scale: 1,
      animation: {
        duration: 800,
        easingFunction: "easeOutCubic"
      }
    });
  }
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.network-container {
    background: #fff;
    margin: 0 0 15px 0;

    position: relative;
    overflow: hidden;
}

.network-container .panel-heading {
    position: relative;
}

.network-graph-title {
    font-weight: bold;
    margin-top: 0;
    margin-bottom: 0;
    font-family: $now-sp-font-family-sans-serif;
    color: #eee;
    font-size: 1.5rem;
}

.refresh-icon {
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
}

.graph-container {
    height: 70vh;
    min-height: 400px;
}

.graph-filter {
    padding: 12px 16px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    align-items: center;
    gap: 12px;
}

.legend-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    justify-content: flex-end;
    margin-left: auto;
}

.legend-header {
    width: 100%;
    font-size: 13px;
    font-weight: bold;
    color: #666;
    margin: 0 0 5px 0;
    padding: 0;
    text-align: right;
}

.legend-item {
    display: flex;
    align-items: center;
    font-size: 12px;
    cursor: pointer;
    transition: opacity 0.2s ease-in-out;
}

.legend-color-box {
    width: 12px;
    height: 12px;
    border: 1px solid #ccc;
    margin-right: 5px;
    border-radius: 2px;
}

.legend-item-hidden {
    opacity: 0.4;
    text-decoration: line-through;
    cursor: pointer;
}

.empty-state-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 70vh;
    min-height: 400px;
    padding: 40px;
}

.network-view-toggle {
    background-color: #fff;
    border-radius: 0.6rem;
    border: 0.1rem solid #ccc;
    color: #10171a;
    padding: 0.8rem 1.4rem;
}

.sidebar-container {
    position: absolute;
    top: 0;
    right: 0;
    width: 320px;
    height: 100%;
    background-color: #fff;
    box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    transform: translateX(100%); /* Start off-screen */
    transition: transform 0.3s ease-in-out;
    border-left: 1px solid #e5e5e5;

    display: flex;
    flex-direction: column;
}

.sidebar-open {
    transform: translateX(0); /* Slide in */
}

/* Re-using some modal classes for consistency */
.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #e5e5e5;
}

.sidebar-title {
    margin: 0;
    font-size: 18px;
    font-weight: bold;
}

.sidebar-body {
    padding: 15px;
    flex: 1;
    overflow-y: auto;
}

.network-role-primary {
    color: #007bff !important;
}

.network-role-success {
    color: #28a745 !important;
}

.network-role-info {
    color: #17a7b8 !important;
}

.activity-feed {
    font-size: 14px;
}

.activity-item {
    margin-bottom: 12px;
    line-height: 1.4;
}

.activity-text {
    margin-bottom: 2px;
}

.recipient-name {
    font-weight: 600; /* Bolder font */
    color: #337ab7; /* A distinct blue color */
}

.activity-message {
    padding-left: 10px;
    display: block; /* Ensures it sits on its own line */
    font-size: 13px;
}

.occasions-container {
    margin-top: 5px;
    padding-left: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.badge {
    font-weight: 500;
    font-size: 11px;
}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>recognition_network_graph</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {  }]]></link>
        <name>Recognition Network Graph</name>
        <option_schema/>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  // We only generate the data if the client has requested it (for async loading).
  if (input && input.action === 'get_graph_data') {
    const occasionIds = input.occasions || [];
    const daysAgo = parseInt(input.timeframe || 0, 10);

    const graphData = new x_1794402_peerce_0.RecognitionDAO().getGraphData(occasionIds, daysAgo);
    data.nodes = graphData.nodes;
    data.edges = graphData.edges;

    data.legendData = graphData.groups;

    return;
  }

  if (input && input.action === 'get_recognition_details') {
    data.details = new x_1794402_peerce_0.RecognitionDAO().getRecognitionDetails(input.userId);
    return;
  }

  data.currentUserId = gs.getUserID();

  data.nodeScalingFilterWidget = $sp.getWidget('single-select-filter', {
    title: 'Scale nodes by',
    eventName: 'graph.scale.filter.updated',
    choices: [
      { display: 'Total Recognitions', value: 'total' },
      { display: 'Sent Recognitions', value: 'sent' },
      { display: 'Received Recognitions', value: 'received' }
    ],

    initialSelection: 'total'
  });

  data.timeframeFilterWidget = $sp.getWidget(
    'single-select-filter',
    {
      title: 'Timeframe',
      eventName: 'graph.timeframe.filter.updated',
      choices: [
        { display: 'All Time', value: 'all' },
        { display: 'Last 90 days', value: '90' },
        { display: 'Last 30 days', value: '30' },
        { display: 'Last 7 days', value: '7' }
      ],

      initialSelection: 'all',
    }
  );

  // In your widget's Server Script
  data.viewFilterWidget = $sp.getWidget('single-select-filter', {
    title: 'Graph View',
    eventName: 'graph.view.filter.updated',
    choices: [
      { display: 'Global View', value: 'global' },
      { display: 'My View', value: 'my_view' }
    ],

    initialSelection: 'global'
  });

  const recognitionOccasions =
    new x_1794402_peerce_0.RecognitionUtils().getRecognitionOccasions();

  data.occasionFilterWidget = $sp.getWidget(
    'multi-select-slushbucket-filter',
    {
      title: 'Occasions',
      eventName: 'graph.occasion.filter.updated',
      choices: recognitionOccasions,
      initialSelection: '',
    }
  );

})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>09b1cbe5c3b3665075ea722ed401316c</sys_id>
        <sys_mod_count>290</sys_mod_count>
        <sys_name>Recognition Network Graph</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy/>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sp_widget_09b1cbe5c3b3665075ea722ed401316c</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-29 18:26:44</sys_updated_on>
        <template><![CDATA[<div class="panel panel-primary network-container">

  <div class="panel-heading">
    <h2 tabindex="0" class="network-graph-title panel-title"><i class="fa fa-share-alt" aria-hidden="true"></i>
      Recognition Network</h2>
    <span class="glyphicon glyphicon-refresh refresh-icon" ng-click="c.loadGraphData()"></span>
  </div>

  <div class="graph-filter">
    <div class="filter-wrapper">
      <sp-widget widget="c.data.nodeScalingFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.timeframeFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.occasionFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <button type="button" class="btn btn-secondary network-view-toggle" ng-click="c.toggleMyNetwork()"
        title="{{ c.showMyNetwork ? 'Show complete recognition network' : 'Show only your direct recognition network' }}">
        {{ c.showMyNetwork ? 'Show Full Network' : 'Show My Network' }}
      </button>
    </div>

    <a href ng-click="c.resetFilters()" ng-show="c.hasActiveFilters()" class="reset-link" title="Reset filters">↺</a>

    <div class="legend-container" ng-if="c.data.legendData.length > 0">
      <h4 class="legend-header">Departments</h4>
      <div ng-repeat="item in c.data.legendData" class="legend-item" ng-click="c.toggleGroup(item)"
        ng-class="{'legend-item-hidden': c.isGroupHidden(item)}">
        <span class="legend-color-box" ng-style="{'background-color': c.getColorForGroup(item)}"></span>
        {{item}}
      </div>
    </div>

  </div>

  <div ng-if="c.isLoading" class="text-center mt-10">
    <i class="fa fa-spinner fa-spin fa-2x"></i>
    <p>Loading graph data...</p>
  </div>

  <div ng-if="!c.isLoading && c.data.nodes.length === 0" class="empty-state-container text-center text-muted">
    <i class="fa fa-info-circle fa-3x" aria-hidden="true"></i>
    <h4 class="mt-3">No Recognition Data Found</h4>
    <p>
      There is no recognition data available for the selected filters. <br>
      Try selecting a different timeframe or resetting the filters.
    </p>
  </div>

  <div ng-if="!c.isLoading && c.data.nodes.length > 0" id="recognition-graph-container" class="graph-container">
  </div>


  <div class="sidebar-container" ng-class="{'sidebar-open': c.selectedNode}">
    <div class="sidebar-header">
      <h4 class="sidebar-title">{{c.selectedNode.label}}</h4>
      <button type="button" class="close" ng-click="c.closeModal()">&times;</button>
    </div>

    <div class="sidebar-body">
      <p><strong>Department:</strong> {{c.selectedNode.group}}</p>

      <p><strong>Network Role:</strong>
        <span
          ng-if="c.selectedNode.sent >= c.roleThresholds.sent && c.selectedNode.received >= c.roleThresholds.received"
          class="network-role-primary">
          Key Connector
        </span>
        <span
          ng-if="c.selectedNode.received >= c.roleThresholds.received && c.selectedNode.sent < c.roleThresholds.sent"
          class="network-role-success">
          Highly Recognized
        </span>
        <span
          ng-if="c.selectedNode.sent >= c.roleThresholds.sent && c.selectedNode.received < c.roleThresholds.received"
          class="network-role-info">
          Recognition Leader
        </span>
        <span
          ng-if="c.selectedNode.sent < c.roleThresholds.sent && c.selectedNode.received < c.roleThresholds.received">
          Active Participant
        </span>
      </p>

      <em class="small text-muted">
        {{ c.getRoleExplanation(c.selectedNode) }}
      </em>


      <hr>
      <h4>Recognition Stats</h4>
      <p><strong>Recognitions Sent:</strong> {{c.selectedNode.sent || 0}}</p>
      <p><strong>Recognitions Received:</strong> {{c.selectedNode.received || 0}}</p>

      <hr>
      <h4>Recent Activity</h4>
      <div ng-if="c.selectedNode.loadingDetails" class="text-center">
        <i class="fa fa-spinner fa-spin"></i> Loading...
      </div>

      <ul ng-if="!c.selectedNode.loadingDetails" class="list-unstyled activity-feed">
        <li ng-repeat="item in c.selectedNode.details" class="activity-item">
          <div class="activity-text">
            <strong ng-class="{'text-success': item.type === 'Received', 'text-info': item.type === 'Sent'}">
              {{item.type}}:
            </strong>
            <span ng-if="item.type === 'Sent'">You recognized <span
                class="recipient-name">{{item.recipientNames}}</span></span>
            <span ng-if="item.type === 'Received'">You received recognition from <span
                class="recipient-name">{{item.senderName}}</span></span>
          </div>
          <em class="text-muted activity-message">"{{item.message}}"</em>

          <div class="occasions-container" ng-if="item.occasions.length > 0">
            <span ng-repeat="occasion in item.occasions" class="badge badge-default">
              {{occasion}}
            </span>
          </div>
        </li>

        <li ng-if="c.selectedNode.details.length === 0">
          No recent activity found.
        </li>
      </ul>

    </div>

  </div>



</div>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>09b1cbe5c3b3665075ea722ed401316c</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>81b10fe5c3b3665075ea722ed401319b</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-05 12:42:38</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
