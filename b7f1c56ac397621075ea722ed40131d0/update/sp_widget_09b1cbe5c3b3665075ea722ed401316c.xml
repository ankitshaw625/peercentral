<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function ($scope, $timeout) {
  /* widget controller */
  var c = this;

  c.currentScale = 'total';
  c.selectedOccasions = [];
  c.timeframe = 'all';

  var networkInstance = null;
  var originalNodes = [];

  // This function runs automatically when the widget initializes
  c.$onInit = function () {
    c.loadGraphData();
  };

  c.loadGraphData = function () {
    // Set a flag to show the loading indicator
    c.isLoading = true;

    // Call the server to get the graph data
    console.log(c);

    c.server.get({
      action: 'get_graph_data',
      occasions: c.selectedOccasions,
      timeframe: c.timeframe
    }).then(function (response) {
      // Once the data comes back, store it
      c.data.nodes = response.data.nodes;
      c.data.edges = response.data.edges;

      originalNodes = c.data.nodes.map(n => ({ ...n }));

      // Turn off the loading indicator
      c.isLoading = false;

      // Now, initialize the graph (inside a $timeout to ensure the container is visible)
      $timeout(function () {
        initializeGraph();
      });
    });
  };

  c.updateScale = function (scale) {
    if (!networkInstance || !originalNodes.length) return;

    const currentView = saveView();
    const scaleBy = scale || c.currentScale;

    // First, update tooltips instantly (no need to animate text)
    const currentNodes = networkInstance.body.data.nodes;
    var targetValues = {};

    originalNodes.forEach(function (node) {
      var value, tooltip;

      if (scaleBy === 'sent') {
        value = node.sent || 0;
        tooltip = node.label + " - Recognitions Sent: " + (node.sent || 0);
      } else if (scaleBy === 'received') {
        value = node.received || 0;
        tooltip = node.label + " - Recognitions Received: " + (node.received || 0);
      } else {
        value = (node.sent || 0) + (node.received || 0);
        tooltip = node.label + " - Recognitions (Sent: " + (node.sent || 0) + ", Received: " + (node.received || 0) + ")";
      }

      // Update tooltip immediately
      currentNodes.update({
        id: node.id,
        title: tooltip
      });

      targetValues[node.id] = value;
    });

    // Animate size change over 600ms
    animateNodeSizes(targetValues, 600);

    if (currentView) {
      setTimeout(function () {
        restoreView(currentView);
      }, 650); // Slightly after animation ends
    }
  };

  $scope.$on('graph.scale.filter.updated', function (event, data) {
    c.updateScale(data.selected.value);
  });

  $scope.$on('graph.occasion.filter.updated', function (event, data) {
    c.selectedOccasions = data.selected.map((item) => item.value);
    c.loadGraphData();
  });

  $scope.$on('graph.timeframe.filter.updated', function (event, data) {
    c.timeframe = data.selected.value;
    c.loadGraphData();
  });

  c.hasActiveFilters = function () {
    return c.currentScale !== 'total' ||
      c.selectedOccasions.length > 0 ||
      c.timeframe !== 'all';
  };

  c.resetFilters = function () {
    // 1. Tell all listening child widgets to reset themselves
    $rootScope.$broadcast('filters.reset');

    c.currentScale = 'total';
    c.selectedOccasions = [];
    c.timeframe = 'all';

    c.loadGraphData();
  };

  function animateNodeSizes(targetValues, duration) {
    if (!networkInstance) return;

    const nodes = networkInstance.body.data.nodes;
    const startValues = {};
    const startTime = performance.now();

    originalNodes.forEach(node => {
      const current = nodes.get(node.id);
      startValues[node.id] = current?.value || 0;
    });

    function step(now) {
      const progress = Math.min((now - startTime) / duration, 1);

      originalNodes.forEach(node => {
        const start = startValues[node.id];
        const end = targetValues[node.id];
        const value = start + (end - start) * progress;

        nodes.update({ id: node.id, value });
      });

      if (progress < 1) requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  }


  function saveView() {
    if (!networkInstance) return null;
    return {
      position: networkInstance.getViewPosition(),
      scale: networkInstance.getScale()
    };
  }

  function restoreView(view) {
    if (!networkInstance || !view) return;

    networkInstance.moveTo({
      position: view.position,
      scale: view.scale,
      animation: false
    });
  }


  var graphOptions = {
    nodes: {
      shape: 'dot',
      size: 10,
      font: { size: 14, face: 'Source Sans Pro', color: '#333' },
      borderWidth: 2,
      scaling: { min: 10, max: 30 }
    },

    edges: {
      scaling: { min: 0.2, max: 2.0 },
      color: { inherit: 'from' },
      smooth: { type: 'continuous' },
      arrows: { to: { enabled: true, scaleFactor: 0.5 } }
    },

    physics: {
      solver: 'barnesHut',

      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 100,
        avoidOverlap: 1.0
      },

      stabilization: { iterations: 2000 }
    },

    interaction: {
      tooltipDelay: 200,
      navigationButtons: true
    }
  };

  function initializeGraph() {
    if (!c.data.nodes || c.data.nodes.length === 0) return;

    var processedNodes = c.data.nodes.map(function (node) {
      var newNode = { ...node };

      newNode.value = node.sent + node.received;

      newNode.color = {
        background: '#4A90E2',
        border: '#357ABD',
        highlight: {
          background: '#6BB5FF',
          border: '#2C5AA0'
        }
      };

      newNode.shape = 'dot';
      newNode.title = node.label + ' - Recognitions (Sent: ' + node.sent + ', Received: ' + node.received + ')';
      return newNode;

    });

    var nodes = new vis.DataSet(processedNodes);
    var edges = new vis.DataSet(c.data.edges);

    var container = document.getElementById('recognition-graph-container');
    var data = { nodes, edges };


    networkInstance = new vis.Network(container, data, graphOptions);

    networkInstance.once("stabilizationIterationsDone", centerNetworkView);
  }

  function centerNetworkView() {
    const positions = networkInstance.getPositions();
    let sumX = 0, sumY = 0, count = 0;

    for (const id in positions) {
      sumX += positions[id].x;
      sumY += positions[id].y;
      count++;
    }

    const center = { x: sumX / count, y: sumY / count };

    networkInstance.moveTo({
      position: center,
      scale: 1,
      animation: {
        duration: 800,
        easingFunction: "easeOutCubic"
      }
    });
  }
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.network-container {
    background: #fff;
    margin: 0 0 15px 0;
}

.network-container .panel-heading {
    position: relative;
}

.network-graph-title {
    font-weight: bold;
    margin-top: 0;
    margin-bottom: 0;
    font-family: $now-sp-font-family-sans-serif;
    color: #eee;
    font-size: 1.5rem;
}

.refresh-icon {
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
}

.graph-container {
    height: 448px;
}

.graph-filter {
    padding: 12px 16px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    align-items: center;
    gap: 12px;
}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>recognition_network_graph</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {  }]]></link>
        <name>Recognition Network Graph</name>
        <option_schema/>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  // We only generate the data if the client has requested it (for async loading).
  if (input && input.action === 'get_graph_data') {
    const occasionIds = input.occasions || [];
    const daysAgo = parseInt(input.timeframe || 0, 10);

    const graphData = new x_1794402_peerce_0.RecognitionDAO().getGraphData(occasionIds, daysAgo);
    data.nodes = graphData.nodes;
    data.edges = graphData.edges;

    return;
  }

  data.nodeScalingFilterWidget = $sp.getWidget('single-select-filter', {
    title: 'Scale nodes by',
    eventName: 'graph.scale.filter.updated',
    choices: [
      { display: 'Total Recognitions', value: 'total' },
      { display: 'Sent Recognitions', value: 'sent' },
      { display: 'Received Recognitions', value: 'received' }
    ],

    initialSelection: 'total'
  });

  data.timeframeFilterWidget = $sp.getWidget(
    'single-select-filter',
    {
      title: 'Timeframe',
      eventName: 'graph.timeframe.filter.updated',
      choices: [
        { display: 'All Time', value: 'all' },
        { display: 'Last 90 days', value: '90' },
        { display: 'Last 30 days', value: '30' },
        { display: 'Last 7 days', value: '7' }
      ],

      initialSelection: '0',
    }
  );

  const recognitionOccasions =
    new x_1794402_peerce_0.RecognitionUtils().getRecognitionOccasions();

  data.occasionFilterWidget = $sp.getWidget(
    'multi-select-slushbucket-filter',
    {
      title: 'Occasions',
      eventName: 'graph.occasion.filter.updated',
      choices: recognitionOccasions,
      initialSelection: '',
    }
  );

})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>09b1cbe5c3b3665075ea722ed401316c</sys_id>
        <sys_mod_count>178</sys_mod_count>
        <sys_name>Recognition Network Graph</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy/>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sp_widget_09b1cbe5c3b3665075ea722ed401316c</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-28 15:44:04</sys_updated_on>
        <template><![CDATA[<div class="panel panel-primary network-container">

  <div class="panel-heading">
    <h2 tabindex="0" class="network-graph-title panel-title"><i class="fa fa-share-alt" aria-hidden="true"></i>
      Recognition Network</h2>
    <span class="glyphicon glyphicon-refresh refresh-icon" ng-click="c.loadGraphData()"></span>
  </div>

  <div class="graph-filter">
    <div class="filter-wrapper">
      <sp-widget widget="c.data.timeframeFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.nodeScalingFilterWidget"></sp-widget>
    </div>

    <div class="filter-wrapper">
      <sp-widget widget="c.data.occasionFilterWidget"></sp-widget>
    </div>

    <a href ng-click="c.resetFilters()" ng-show="c.hasActiveFilters()" class="reset-link" title="Reset filters">â†º</a>
  </div>

  <div ng-if="c.isLoading" class="text-center mt-10">
    <i class="fa fa-spinner fa-spin fa-2x"></i>
    <p>Loading graph data...</p>
  </div>

  <div ng-if="!c.isLoading" id="recognition-graph-container" class="graph-container">
  </div>
</div>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>09b1cbe5c3b3665075ea722ed401316c</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-05 12:42:38</sys_created_on>
        <sys_id>81b10fe5c3b3665075ea722ed401319b</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-05 12:42:38</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
