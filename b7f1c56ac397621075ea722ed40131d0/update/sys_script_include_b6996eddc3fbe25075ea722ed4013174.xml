<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1794402_peerce_0.RecognitionUtils</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>RecognitionUtils</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[
var RecognitionUtils = Class.create();
RecognitionUtils.prototype = {
  initialize: function () {
    this.userTeam = null;
    this.RECOGNITION_TABLE = RecognitionUtils.tables.RECOGNITION_TABLE;
    this.RECOGNITION_RECIPIENT_TABLE = RecognitionUtils.tables.RECOGNITION_RECIPIENT_TABLE;

  },

  canReadPrivateRecognition: function (grRecognition, userId) {
    userId = userId || gs.getUserID();

    var recognitionDAO = new x_1794402_peerce_0.RecognitionDAO();

    // Check if current user is the sender
    if (userId == grRecognition.getValue('sender')) return true;

    // Check if current user is part of the notify to list
    if (grRecognition.notify_to.toString().includes(userId)) return true;

    var recognitionSysId = grRecognition.sys_id.toString();
    var isTeam = grRecognition.is_team.toString() == 'true';

    var recipientData = recognitionDAO.getRecognitionRecipients(recognitionSysId, isTeam);

    var recognitionRecipients = recipientData.userIds || [];

    // If it's a team fetch and add the team members
    if (isTeam) {
      var teamMembers = this.getGroupMembers(recognitionRecipients);
      recognitionRecipients = recognitionRecipients.concat(teamMembers);
    }

    // Check if the current user is one of the recipients
    return recognitionRecipients.includes(userId);
  },

  isTeamRecognition: function (sender, recipients) {
    if (!this.userTeam) {
      this.userTeam = this.getUserTeam();
    }

    gs.info(JSON.stringify(this.userTeam));

    var allTeam = this.userTeam.combined;

    if (allTeam.includes(sender)) return true;

    return recipients.some(recipient => allTeam.includes(recipient));
  },

  getUserTeam: function (userId) {
    userId = userId || gs.getUserID();

    var userGroups = this.getUserGroups(userId);

    var teamMembers = this.getGroupMembers(userGroups);

    return {
      userGroups: userGroups,
      teamMembers: teamMembers,
      combined: userGroups.concat(teamMembers)
    };
  },

  getGroupMembers: function (groupIds) {
    const groupMembers = new Set();

    const grGroupMember = new GlideRecord('sys_user_grmember');
    grGroupMember.addQuery('group', 'IN', groupIds.toString());
    grGroupMember.query();

    while (grGroupMember.next()) {
      groupMembers.add(grGroupMember.getValue('user'));
    }

    return Array.from(groupMembers);
  },

  getUserGroups: function (userId) {
    userId = userId || gs.getUserID();

    var userGroups = new Set();

    var grGroupMember = new GlideRecord('sys_user_grmember');
    grGroupMember.addQuery('group.active', true);
    grGroupMember.addQuery('user', userId).addOrCondition('group.manager', userId);
    grGroupMember.query();

    while (grGroupMember.next()) {
      userGroups.add(grGroupMember.group.toString());
    }

    return Array.from(userGroups);
  },

  getUserRecognitionSnapshot: function (userID, days) {
    userID = userID || gs.getUserID();
    days = parseInt(days, 10) || 90;

    var given = this._getUserCount(this.RECOGNITION_TABLE, 'sender', userID, days);
    var received = this._getUserCount(this.RECOGNITION_RECIPIENT_TABLE, 'recipient_user', userID, days);

    return {
      given: given,
      received: received,
      total: given + received
    };
  },

  _getUserCount: function (tableName, userField, userID, days) {
    var ga = new GlideAggregate(tableName);
    ga.addQuery(userField, userID);
    ga.addQuery('sys_created_on', '>=', gs.daysAgo(days));
    ga.addAggregate('COUNT');
    ga.query();

    var count = 0;
    if (ga.next()) {
      count = parseInt(ga.getAggregate('COUNT'), 10);
    }
    return count;
  },


  getTopRecognitionContributors: function (daysAgo, userCount) {
    daysAgo = parseInt(daysAgo, 10) || 90;
    userCount = userCount || 3;

    const allRecognitions = [];
    const givenRecognitions = [];
    const receivedRecognitions = [];

    const givenMap = this._getCounts(this.RECOGNITION_TABLE, 'sender', daysAgo);
    const receivedMap = this._getCounts(this.RECOGNITION_RECIPIENT_TABLE, 'recipient_user', daysAgo);

    const totalsMap = new Map();

    // Add 'given' counts to the totals
    givenMap.forEach(function (value, key) {
      totalsMap.set(key, {
        user: key,
        displayName: value.displayName,
        count: value.count
      });
    });

    // Add 'received' counts to the totals
    receivedMap.forEach(function (value, key) {
      if (totalsMap.has(key)) {
        totalsMap.get(key).count += value.count;
      } else {
        totalsMap.set(key, {
          user: key,
          displayName: value.displayName,
          count: value.count
        });
      }
    });

    return {
      all: this._sortAndSlice(totalsMap, userCount),
      given: this._sortAndSlice(givenMap, userCount),
      received: this._sortAndSlice(receivedMap, userCount)
    };
  },

  // Helper function to sort and slice an array from a map
  _sortAndSlice: function (map, count) {
    return Array.from(map.values())
      .sort(function (a, b) {
        return b.count - a.count;
      })
      .slice(0, count);
  },

  _getCounts: function (tableName, userField, days) {

    const resultsMap = new Map();

    const ga = new GlideAggregate(tableName);
    ga.addQuery('sys_created_on', '>=', gs.daysAgo(days));
    ga.addNotNullQuery(userField);
    ga.addAggregate('COUNT', userField);
    ga.groupBy(userField);
    ga.orderByAggregate('COUNT', userField);
    ga.query();

    while (ga.next()) {
      const userId = ga.getValue(userField);
      const userDisplayName = ga.getDisplayValue(userField);
      const count = parseInt(ga.getAggregate('COUNT', userField), 10);

      if (userId && userDisplayName) {
        resultsMap.set(userId, {
          user: userId,
          displayName: userDisplayName,
          count: count
        });
      }
    }

    return resultsMap;
  },

  getRecognitionOccasions: function () {
    const occasions = [];

    const grOccasions = new GlideRecord('x_1794402_peerce_0_recognition_category');
    grOccasions.addActiveQuery();
    grOccasions.query();

    while (grOccasions.next()) {
      occasions.push({
        display: grOccasions.getDisplayValue(),
        value: grOccasions.getUniqueValue()
      });
    }

    return occasions;
  },

  getInitials: function (fullName) {
    const nameParts = fullName.trim().split(' ');

    const initials = nameParts.map(part => part.charAt(0).toUpperCase());

    return initials.join('');
  },


  // HELPER METHODS FOR GENERATING MANAGER'S DIGEST

  // Generate and send the recognition digest email for a manager
  processManagerDigest: function (userId, reportIds) {
    const daysAgo = 7;

    const since = new GlideDateTime();
    since.addDaysUTC(-1 * daysAgo);

    const digestData = {
      given: [],
      received: [],
      stats: {
        given_count: 0,
        received_count: 0,
        top_contributor: 'N/A'
      }
    };


    const givers = new Map();
    const grRecognitions = new GlideRecord(this.RECOGNITION_TABLE);
    grRecognitions.addQuery('sender', 'IN', reportIds);
    grRecognitions.addQuery('sys_created_on', '>=', since);
    grRecognitions.query();

    while (grRecognitions.next()) {
      const senderDisplay = grRecognitions.getDisplayValue('sender');
      // Collect given recognitions for reportees
      digestData.given.push({
        sender: senderDisplay,
        message: grRecognitions.getValue('message'),
        recipient_summary: this.getRecipientSummary(grRecognitions.getValue('sys_id'))
      });

      // Count recognitions per sender for top contributor calculation
      const senderId = grRecognitions.getValue('sender');
      if (!givers.has(senderId)) {
        givers.set(senderId, { name: senderDisplay, count: 0 });
      }

      // Increment the count for this sender
      givers.get(senderId).count += 1;
    }

    digestData.stats.given_count = digestData.given.length;

    if (givers.size > 0) {
      // Find the max count of recognitions given
      let maxCount = 0;
      for (const data of givers.values()) {
        if (data.count > maxCount) {
          maxCount = data.count;
        }
      }

      // Get all givers with the max count
      const winners = [];
      for (const data of givers.values()) {
        if (data.count === maxCount) {
          winners.push(data.name);
        }
      }

      // 3. Sort the winners alphabetically and join them.
      winners.sort();

      digestData.stats.top_contributor = winners.join(', ');
    }


    const managedGroupIds = this._getManagedGroups(userId);

    const receivedRecognitions = new Map();
    let totalReceivedCount = 0;

    // Collect received recognitions for reportees and managed groups
    const grRecognitionRecipients = new GlideRecord(this.RECOGNITION_RECIPIENT_TABLE);
    grRecognitionRecipients
      .addQuery('recipient_user', 'IN', reportIds)
      .addOrCondition('recipient_group', 'IN', managedGroupIds);
    grRecognitionRecipients.addQuery('sys_created_on', '>=', since);
    grRecognitionRecipients.query();

    while (grRecognitionRecipients.next()) {
      totalReceivedCount++;

      const recognitionId = grRecognitionRecipients.getValue('recognition');

      let recipientName = grRecognitionRecipients.getDisplayValue('recipient_user');
      if (!grRecognitionRecipients.recipient_group.nil())
        recipientName = grRecognitionRecipients.getDisplayValue('recipient_group') + ' (Team)';


      if (!receivedRecognitions.has(recognitionId)) {
        receivedRecognitions.set(recognitionId, {
          recipient: recipientName,
          message: grRecognitionRecipients.getDisplayValue('recognition.message'),
          sender: grRecognitionRecipients.getDisplayValue('recognition.sender')
        });
      } else {
        const existingRecognition = receivedRecognitions.get(recognitionId);
        existingRecognition.recipient += ', ' + recipientName;
      }
    }

    digestData.received = Array.from(receivedRecognitions.values());
    digestData.stats.received_count = totalReceivedCount;

    gs.info("RecognitionUtils: Prepared digest data for manager " + userId + ": " + JSON.stringify(digestData, null, 2));

    // Send the digest email if there are any recognitions
    if (digestData.given.length > 0 || digestData.received.length > 0) {
      gs.eventQueue('x_1794402_peerce_0.manager.digest', null, userId, JSON.stringify(digestData));
      gs.info("RecognitionUtils: Queued digest email for manager " + userId);
    }
  },

  // Generate a summary string of recognition recipients
  getRecipientSummary: function (recognitionId) {
    const recipients = [];

    const grRecipient = new GlideRecord(this.RECOGNITION_RECIPIENT_TABLE);
    grRecipient.addQuery('recognition', recognitionId);
    grRecipient.query();

    while (grRecipient.next()) {

      if (!grRecipient.recipient_user.nil())
        recipients.push(grRecipient.getDisplayValue('recipient_user'));


      if (!grRecipient.recipient_group.nil())
        recipients.push(grRecipient.getDisplayValue('recipient_group'));
    }

    const recipientCount = recipients.length;
    if (recipientCount === 0) return 'N/A';
    if (recipientCount === 1) return recipients[0];

    return recipients[0] + ' and ' + (recipientCount - 1) + ' other(s)';
  },

  // Get all users managed by the given user (direct reports + managed group members)
  getManagedUsers: function (userId) {
    userId = userId || gs.getUserID();

    const directReports = this._getDirectReports(userId);

    const managedGroups = this._getManagedGroups(userId);

    let groupMembers = [];
    if (managedGroups.length > 0) {
      groupMembers = this.getGroupMembers(managedGroups);
    }

    const allTeamMembers = directReports.concat(groupMembers);

    return Array.from(new Set(allTeamMembers));
  },

  // Get direct reports of the given user
  _getDirectReports: function (userId) {
    const reports = [];

    const userGR = new GlideRecord('sys_user');
    userGR.addActiveQuery();
    userGR.addQuery('manager', userId);
    userGR.query();

    while (userGR.next()) {
      reports.push(userGR.getValue('sys_id'));
    }

    return reports;
  },

  // Get groups managed by the given user
  _getManagedGroups: function (userId) {
    const groupIds = [];

    const groupGR = new GlideRecord('sys_user_group');
    groupGR.addActiveQuery();
    groupGR.addQuery('manager', userId);
    groupGR.query();

    while (groupGR.next()) {
      groupIds.push(groupGR.getValue('sys_id'));
    }

    return groupIds;
  },

  type: 'RecognitionUtils'
};


RecognitionUtils.tables = {
  RECOGNITION_TABLE: 'x_1794402_peerce_0_peer_recognition',
  RECOGNITION_RECIPIENT_TABLE: 'x_1794402_peerce_0_recognition_recipient'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-04 16:33:59</sys_created_on>
        <sys_id>b6996eddc3fbe25075ea722ed4013174</sys_id>
        <sys_mod_count>43</sys_mod_count>
        <sys_name>RecognitionUtils</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sys_script_include_b6996eddc3fbe25075ea722ed4013174</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-20 19:38:15</sys_updated_on>
    </sys_script_include>
</record_update>
