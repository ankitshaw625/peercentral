<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function ($scope, $location, spUtil, $timeout, $anchorScroll) {
  var c = this;

  const MAX_RECIPIENTS_TO_SHOW = 2;
  const FEED_TABS = ['you', 'team', 'all'];

  c.currentUserId = $scope.user.sys_id;
  c.currentUserInitials = generateInitials($scope.user.name);

  const userPhoto = $scope.user.photo;
  c.userImage = userPhoto ? userPhoto.split('.')[0] : '';

  c.data.filteredRecognitions = [];
  c.isLoading = false;
  c.isLoadingMore = false;
  c.canLoadMore = true;
  c.showRefreshIndicator = false; // Flag to show the new recognition indicator

  c.offset = 0;
  c.limit = c.options.limit || 10;

  // Default filter state
  c.filters = getDefaultFilters();

  // Controller variables for displaying single recognition
  c.singleRecognitionMode = false;
  c.singleRecognition = null;
  c.loadingSingle = false;

  // This function now simply broadcasts a message and then re-fetches the data.
  c.resetFilters = function () {
    // Tell all listening child widgets to reset themselves
    $scope.$broadcast('filters.reset');

    c.showRefreshIndicator = false;

    // Reset the parent's data model
    c.filters = getDefaultFilters();

    // Fetch the new, unfiltered data
    applyFiltersAndReload();
  };

  // Check if any filter is active
  c.hasActiveFilters = function () {
    return c.filters.activity !== 'all' ||
      c.filters.timeframe !== 'all' ||
      c.filters.occasions.length > 0 ||
      c.filters.team.length > 0 ||
      c.filters.teamMember.length > 0;
  };


  c.setTab = function (tabName) {
    if (c.singleRecognitionMode) {
      c.goBackToFeed();
    }

    if (FEED_TABS.includes(tabName)) {
      $location.hash(tabName);
    }
  };

  const initialHash = $location.hash();
  const tabToLoad = FEED_TABS.includes(initialHash) ? initialHash : 'you';

  c.activeTab = tabToLoad;

  const urlParams = $location.search();
  if (urlParams.recognition_id) {
    loadSingleView(urlParams.recognition_id);
  } else {
    applyFiltersAndReload();
  }

  if (FEED_TABS.includes(initialHash) || !initialHash) {
    $location.hash(tabToLoad);
  }

  $scope.$on('$locationChangeSuccess', function () {
    const hash = $location.hash();
    const tabToLoad = FEED_TABS.includes(hash) ? hash : 'you';

    if (c.activeTab === tabToLoad) return;

    c.activeTab = tabToLoad;
    applyFiltersAndReload();
  });


  c.loadMore = function () {
    if (!c.canLoadMore || c.isLoadingMore) return;

    c.isLoadingMore = true;

    loadFeed(c.activeTab, c.offset, true);
  };

  // Hide refresh banner and do a feed refresh
  c.refreshAndShow = function () {
    c.showRefreshIndicator = false;
    c.setTab(c.activeTab);
  };

  // Toggle like/unlike reaction
  c.toggleReaction = function (recognition) {
    const originalReactionState = recognition.currentUserHasReacted;
    const originalReactions = [...recognition.reactions];
    const originalToolTip = recognition.reactionTooltip;


    // Only allow reaction animation when like is being added, false by default to prevent animation on initial load
    recognition._allowReactionAnimation = true;

    // Instantly update the UI for responsiveness
    recognition.currentUserHasReacted = !originalReactionState;

    if (originalReactionState) {
      // If this was previously liked, remove the like from the list on the UI
      recognition.reactions =
        recognition.reactions.filter(r => r.userId !== c.currentUserId);
    } else {
      // Otherwise, add a like to the list with the current user's details
      recognition.reactions.push({
        userId: c.currentUserId,
        userName: $scope.user.name,
        created: new Date().toISOString()
      });
    }

    recognition.reactionTooltip = recognition.reactions.map(r => r.userName).join(', ');

    c.server.get({
      action: 'toggle_recognition_reaction',
      recognitionId: recognition.id
    }).then(function (response) {
      // console.log('Toggle reaction response: ', response);

      if (!response.data.toggleReactionSuccess) {
        // In case of failure, revert the UI update
        recognition.currentUserHasReacted = originalReactionState;
        recognition.reactions = originalReactions;
        recognition.reactionTooltip = originalToolTip;

        // Show feedback to user
        spUtil.addErrorMessage('Your like could not be saved. Please try again.');
      }
    });
  };

  c.toggleCommentReaction = function (comment) {
    const currentUserName = $scope.user.name;
    const originalReactedState = comment.currentUserHasReacted;
    const originalLikeCount = comment.likeCount;
    const originalLikedByNames = [...comment.likedByNames];
    const originalTooltip = comment.commentReactionTooltip;

    // Only allow reaction animation when like is being added, false by default to prevent animation on comment load
    comment._allowReactionAnimation = true;

    // Update the UI immediately for responsiveness
    if (comment.currentUserHasReacted) {
      comment.likeCount--;
      comment.likedByNames = comment.likedByNames.filter(name => name !== currentUserName);
    } else {
      comment.likeCount++;
      comment.likedByNames.push(currentUserName);
    }

    comment.currentUserHasReacted = !comment.currentUserHasReacted;
    comment.commentReactionTooltip = comment.likedByNames.join(', ');

    c.server.get({
      action: 'toggle_comment_reaction',
      commentId: comment.id,
      recognitionId: comment.recognitionId
    }).then(function (response) {
      // Revert the UI update if the server call failed
      if (!response.data.toggleCommentReactionSuccess) {
        comment.currentUserHasReacted = originalReactedState;
        comment.likeCount = originalLikeCount;
        comment.likedByNames = originalLikedByNames;
        comment.commentReactionTooltip = originalTooltip;

        spUtil.addErrorMessage('Your like could not be saved. Please try again.');
      }
    });
  };

  c.toggleComments = function (recognition) {
    recognition.showComments = !recognition.showComments;
  };

  // Submit comment (UI only)
  c.submitComment = function (recognition) {
    const text = (recognition.newCommentText || '').trim();
    if (!text) return;

    const tempId = 'temp-' + Date.now();
    const newComment = {
      id: tempId,
      text: text,
      authorName: $scope.user.name,
      userInitials: c.currentUserInitials,
      userId: c.currentUserSysId,
      timeAgo: 'Just now',
      isSaving: true,
    };

    recognition.comments.push(newComment);
    recognition.newCommentText = '';

    // Make the server call to save the comment
    c.server.get({
      action: 'add_comment',
      recognitionId: recognition.id,
      commentText: text
    }).then(function (response) {
      const newComment = response.data.newComment;
      const commentIndex = recognition.comments.findIndex(c => c.id === tempId);

      if (newComment && commentIndex > -1) {
        // Replace the temporary comment with the real one from the server
        const transformedComment = {
          ...newComment,
          timeAgo: formatTimeAgo(newComment.created),
          authorInitials: generateInitials(newComment.authorName)
        };

        recognition.comments.splice(commentIndex, 1, transformedComment);
        return;
      }

      // If the server fails, remove the temp comment and show an error
      if (commentIndex > -1) recognition.comments.splice(commentIndex, 1);

      spUtil.addErrorMessage('Your comment could not be posted. Please try again.');
      recognition.newCommentText = text;
    });
  };


  // Event listeners for filters
  $scope.$on('activity.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.activity !== data.selected.value) {
      c.filters.activity = data.selected.value;
      // c.setTab(c.activeTab);
      applyFiltersAndReload();
    }
  });

  $scope.$on('teammember.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    c.filters.teamMember = data.selected.map(item => item.value);
    // c.setTab(c.activeTab);
    applyFiltersAndReload();
  });

  $scope.$on('team.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    c.filters.team = data.selected.map(item => item.value);
    // c.setTab(c.activeTab);
    applyFiltersAndReload();
  });

  $scope.$on('timeframe.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.timeframe !== data.selected.value) {
      c.filters.timeframe = data.selected.value;
      // c.setTab(c.activeTab);
      applyFiltersAndReload();
    }
  });

  $scope.$on('occasion.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    // For multi-select, data.selected is an array of objects
    c.filters.occasions = data.selected.map(item => item.value);
    // c.setTab(c.activeTab);
    applyFiltersAndReload();
  });

  $scope.$on('sort.order.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.sortOrder !== data.selected.value) {
      c.filters.sortOrder = data.selected.value;
      // c.setTab(c.activeTab);
      applyFiltersAndReload();
    }
  });

  c.goBackToFeed = function () {
    c.isLoading = true;

    $location.search('recognition_id', null);

    c.singleRecognitionMode = false;
    c.singleRecognition = null;
  };

  function loadSingleView(recognitionId) {
    c.singleRecognitionMode = true;
    c.loadingSingle = true;

    c.server.get({
      action: 'get_single_recognition',
      recognitionId: recognitionId
    }).then(function (response) {
      c.loadingSingle = false;

      const singleRecognition = response.data.singleRecognition;

      if (!singleRecognition) {
        spUtil.addTrivialMessage('The requested recognition could not be found.');
        c.singleRecognitionMode = false;
        applyFiltersAndReload();
        return;
      }

      const transformed = transformRecognitions([response.data.singleRecognition]);

      c.singleRecognition = transformed[0];

      // Expand comments and input by default
      c.singleRecognition.showComments = true;
    });
  }

  function applyFiltersAndReload() {
    c.data.filteredRecognitions = [];
    c.offset = 0;
    c.canLoadMore = true;
    c.isLoading = true;
    c.showRefreshIndicator = false;

    loadFeed(c.activeTab, 0, false);
  }


  let debounceTimer = null;

  function handleRecognitionInsert(response) {

    if (response.data.operation !== 'insert') return;

    $timeout.cancel(debounceTimer);

    debounceTimer = $timeout(function () {
      const isRelevantView = c.filters.sortOrder === 'newest';
      if (!isRelevantView || c.showRefreshIndicator) return;

      const currentTopId = c.data.filteredRecognitions.length > 0 ? c.data.filteredRecognitions[0].id : null;

      // Check if the new recognition is newer than the current top item
      c.server.get({
        action: 'get_latest_recognition_id',
        feedType: c.activeTab,
        filters: c.filters,
        currentTopId: currentTopId
      }).then(function (response) {
        const payload = response.data.payload;

        if (!payload || !payload.newRecognition) return;

        // Show banner for new recognition sent by others
        if (!payload.isSelf) {
          c.showRefreshIndicator = true;
          return
        }

        const transformedItem = transformRecognitions([payload.newRecognition])[0];

        // Add a flag for the CSS highlight effect
        transformedItem.isNew = true;
        c.data.filteredRecognitions.unshift(transformedItem);
        c.offset++;
      });

    }, 750); // 750ms debounce

  }

  spUtil.recordWatch($scope, 'x_1794402_peerce_0_peer_recognition', '', handleRecognitionInsert);


  function getDefaultFilters() {
    return {
      activity: 'all',
      timeframe: 'all',
      occasions: [],
      sortOrder: 'newest',
      team: [],
      teamMember: []
    };
  }

  function loadFeed(feedType, offset, append) {

    c.server.get({
      feedType,
      limit: c.limit,
      offset,
      filters: c.filters,
      action: 'getFeed'
    })
      .then(function (response) {
        const newRecognitions = transformRecognitions(response.data.recognitions || []);

        if (append) {
          c.data.filteredRecognitions = c.data.filteredRecognitions.concat(newRecognitions);
        } else {
          c.data.filteredRecognitions = newRecognitions;
        }

        // Update the offset
        c.offset = offset + newRecognitions.length;

        // If we got fewer than the limit, no more records left to load
        c.canLoadMore = newRecognitions.length >= c.limit;

      })
      .catch(function (error) {
        console.error('Failed to load feed:', error);
        if (!append) c.data.filteredRecognitions = [];

      }).finally(function () {
        c.isLoading = false;
        c.isLoadingMore = false;
      });
  }

  function transformRecognitions(recognitions) {

    return recognitions.map(function (rec) {
      const transformedComments = (rec.comments || []).map(function (comment) {

        const reactionUsernames = comment.likedByNames.join(', ');

        return {
          ...comment,
          timeAgo: formatTimeAgo(comment.created),
          authorInitials: generateInitials(comment.authorName),
          _allowReactionAnimation: false,
          commentReactionTooltip: reactionUsernames
        };
      });


      // If current user is among the recipients, replace their name with 'You' and move to the front of the list
      const finalRecipients = (rec.recipients || []).slice();
      const currentUserIndex = rec.recipientIds.indexOf(c.currentUserId);
      if (currentUserIndex > -1) {
        finalRecipients.splice(currentUserIndex, 1);
        finalRecipients.unshift('You');
      }

      let visibleRecipients = [];
      let remainingCount = 0;
      let remainingRecipientsTooltip = '';

      if (finalRecipients.length > MAX_RECIPIENTS_TO_SHOW) {
        visibleRecipients = finalRecipients.slice(0, MAX_RECIPIENTS_TO_SHOW);
        remainingCount = finalRecipients.length - MAX_RECIPIENTS_TO_SHOW;
        remainingRecipientsTooltip = finalRecipients.slice(MAX_RECIPIENTS_TO_SHOW).join(', ');
      } else {
        visibleRecipients = finalRecipients;
      }

      const reactionUsernames = (rec.reactions || []).map(r => r.userName);


      return {
        ...rec,
        senderInitials: generateInitials(rec.senderDisplay),
        timeAgo: formatTimeAgo(rec.createdOn),

        reactionTooltip: reactionUsernames.join(', '),

        comments: transformedComments,
        showComments: false,
        newCommentText: '',
        _allowReactionAnimation: false,

        visibleRecipients: visibleRecipients,
        remainingCount: remainingCount,
        remainingRecipientsTooltip: remainingRecipientsTooltip,

        senderDisplay: rec.senderId === c.currentUserId ? 'You' : rec.senderDisplay,
        recipients: finalRecipients
      };
    });
  }

  function generateInitials(name) {
    if (!name) return '?';

    return name.split(/\s+/)
      .map(part => part[0] ? part[0].toUpperCase() : '')
      .join('')
      .substring(0, 2) || '?';
  }


  function formatTimeAgo(dateTime) {
    if (!dateTime) return '';

    var m = moment(dateTime, "YYYY-MM-DD HH:mm:ss");

    return m.fromNow();
  }


  moment.updateLocale('en', {
    relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    }
  });
};]]></client_script>
        <controller_as>c</controller_as>
        <css>li {
    list-style-type: none;
}

.nav-tabs li a:hover {
    cursor: pointer;
}

.nav-tabs &gt; li &gt; a:focus,
.nav-tabs &gt; li &gt; a:active {
    outline: none;
    box-shadow: none;
}

.nav-tabs &gt; li.active &gt; a {
    border: none;
    border-bottom: 0.2rem solid #2d7524;
}

.refresh-btn {
    border-bottom: none;
}

.refresh-btn .fa-refresh {
    font-size: 18px !important;
    color: #666;
    transition: transform 0.1s ease;
}

.refresh-btn:active .fa-refresh {
    transform: scale(0.9);
}

.refresh-btn:focus,
.refresh-btn:active {
    outline: none;
    box-shadow: none !important;
    background-color: transparent !important;
    border-color: transparent !important;
}
/* ───────────────────────────────
  Control Bar
  ─────────────────────────────── */
.controls-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: #fff;
}

.filters {
    display: flex;
    gap: 12px; /* Increased gap for better spacing */
    align-items: center;
}

/* This is a new class for spacing our widgets */
.filter-wrapper {
    display: inline-block;
}

/* ───────────────────────────────
  Reset Link
  ─────────────────────────────── */
.reset-link {
    color: #999;
    text-decoration: none;
    margin-left: 6px;
    line-height: 1;
}

.reset-link:hover {
    color: #2d7524;
}

/* This container is the positioning anchor for the overlay */
.feed-container {
    position: relative;
    scroll-behavior: smooth;
}

/* This is the spinner overlay itself */
.feed-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    display: flex;
    justify-content: center;

    align-items: flex-start;

    padding-top: 50px;

    background: white;
}

/* New recognition banner styles */
.refresh-indicator {
    background-color: #eef6f8;
    border: 1px solid #cce6ec;
    border-radius: 4px;
    color: #005f79;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    margin: 0;
}

.refresh-indicator.is-sticky {
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    z-index: 1020;
    border-radius: 0;
    border-left: none;
    border-right: none;
    border-top: none;
}

.refresh-indicator-content {
    display: flex;
    align-items: center;
    flex-grow: 1;
}

.refresh-indicator-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}

.refresh-icon {
    margin-right: 8px;
    font-size: 16px;
    color: #0080a3;
}

.refresh-indicator .close {
    font-size: 20px;
    line-height: 1;
    opacity: 0.6;
    color: #005f79;
    text-shadow: none;
    padding: 0;
    margin-left: 10px;
}

.refresh-indicator .close:hover {
    opacity: 1;
    color: #000;
}

.refresh-indicator .btn-primary {
    background-color: #0080a3;
    border-color: #0080a3;
    color: #fff;
    font-weight: 600;
    padding: 4px 10px;
    font-size: 12px;
}

.refresh-indicator .btn-primary:hover {
    background-color: #006a88;
    border-color: #006a88;
}

/* This is the list of recognitions */
.feed-content {
    opacity: 1;
    transition: opacity 0.4s linear;
}

.feed-content-item {
    list-style-type: none;
    border: none;
}

.feed-footer {
    border: none;
    background: inherit;
}

.recognition-container {
    border: 1px solid #ddd;
    padding: 10px;
    border-radius: 2px;
}

/* This class is applied to the list when the spinner is active */
.feed-content.content-faded {
    opacity: 0.5;
    pointer-events: none;
}

.new-badge {
    margin-right: 8px;
    vertical-align: middle;
}

.recognition-indicators abbr {
    display: inline-block;
    cursor: pointer;
}

.private-indicator {
    color: #7b6ea2;
}

.team-indicator {
    color: #007bff;
}

.occasion-tag {
    font-size: 1.2rem;
    border-radius: 3px;
}

/* Main interaction row */
.interaction-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-top: 1px solid #eee;
    margin-top: 12px;
}

/* Left group: Like &amp; Comment */
.action-group {
    display: flex;
    gap: 16px;
}

.action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background: none;
    border: none;
    color: #666;
    font-size: 14px;
    cursor: pointer;
    transition: color 0.2s;
    padding: 4px 8px;
    border-radius: 4px;
}

.action-btn:hover {
    background-color: #f8f9fa;
    color: #1955be;
}

.action-btn.active {
    color: #1955be;
}

.action-btn .fa {
    font-size: 14px;
}

.action-btn:focus {
    outline: 0;
    box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.05);
}

@keyframes like-pop {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.4); /* Grow bigger */
    }
    100% {
        transform: scale(1); /* Return to normal size */
    }
}

.action-btn.can-animate.active .fa-thumbs-up {
    animation: like-pop 0.3s ease-in-out;
}

/* Count badge — small pill */
.count-badge {
    background: #e9ecef;
    color: #495057;
    border-radius: 10px;
    padding: 0 6px;
    font-size: 12px;
    min-width: 18px;
    text-align: center;
    margin-left: 4px;
}

/* Icon sizing for thumbs-up in count */
.icon-small {
    font-size: 12px;
    color: #666;
}

/* Right side: reaction count + reply link */
.meta-info {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #666;
}

.icon-small {
    font-size: 12px;
    color: #666; /* or #495057 for slightly darker */
}

.meta-info .reaction-count {
    color: #666;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
}

.reply-link {
    color: #1955be;
    cursor: pointer;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: background-color 0.2s;
}

.reply-link:hover {
    background-color: #f0f8ff;
    text-decoration: none;
}

/* Indicator icon — down arrow in blue circle */
.indicator-icon {
    font-size: 10px;
    color: #1955be;
    background: #e0f0ff;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
}

/* Comment input below buttons */
.comment-input-container {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #f0f0f0;
}

.comment-input-container .form-control {
    font-size: 14px;
    height: 32px;
}

.comment-input-container .btn {
    height: 32px;
}

.comment-input-container .btn-link {
    font-size: 18px;
    padding: 2px 6px;
    margin-left: 4px;
}

/* Match recognition container styling */
.comment-item {
    background-color: #fafafa;
    border: 1px solid #ddd;
    border-radius: 2px;
    padding: 15px 10px;
    font-size: 14px; /* Match recognition body */
    color: #333; /* Default text color like recognition */
}

.comment-item.is-saving {
    opacity: 0.6;
}

.comment-body {
    /* Remove any previous border or background */
    border: none;
    background: none;
    padding: 0;
}

.comment-body .media-heading {
    display: inline-block;
}

.comment-text {
    margin: 10px 0;
}

/* New container for the modern comment input */
.comment-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

.comment-input-wrapper {
    flex-grow: 1; /* Allows the input to take up the remaining space */
    position: relative;
}

/* Style the form-control within our new container */
.comment-input-container .form-control {
    background-color: #f0f2f5; /* A soft, modern gray */
    border: 1px solid #f0f2f5;
    border-radius: 18px; /* Creates the pill shape */
    padding: 6px 15px;
    height: 36px; /* A slightly taller input */
    line-height: 1.5;
    box-shadow: none;
    transition: border-color 0.2s ease-in-out;
}

/* Add a clear focus state for accessibility and better UX */
.comment-input-container .form-control:focus {
    background-color: #fff;
    border-color: #1955be; /* A highlight color */
    box-shadow: none;
}

.comment-input-wrapper {
    flex-grow: 1;
    position: relative; /* Required for absolute positioning of the child button */
}

.btn-send {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    padding: 0 8px;
    color: #1955be;
    font-size: 16px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
}

.btn-send:hover {
    opacity: 1;
}

/* --- START: NEW NG-ANIMATE STYLES for NG-HIDE --- */

/* Base style for the element */
.slide-animation {
    /* Set a transition on max-height */
    transition: max-height 0.4s ease-in-out;
    overflow: hidden;
}

/* This class is added when the element is BEING HIDDEN */
.slide-animation.ng-hide-add {
    /* Start the animation from its full height */
    max-height: 500px; /* Use a value larger than any possible content height */
}
.slide-animation.ng-hide-add.ng-hide-add-active {
    /* End the animation at zero height */
    max-height: 0;
}

/* This class is added when the element is BEING SHOWN */
.slide-animation.ng-hide-remove {
    /* Start the animation from zero height */
    max-height: 0;
}
.slide-animation.ng-hide-remove.ng-hide-remove-active {
    /* End the animation at its full height */
    max-height: 500px; /* Use a value larger than any possible content height */
}

.sub-nav-header {
    padding: 12px 15px; /* Matches panel padding */
    border-bottom: 1px solid #eee; /* Subtle separator */
    background-color: #fff;
}

.back-link {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    text-decoration: none;
    color: #444; /* Softer gray than pure black */
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s ease;
}

/* Circle wrapper for the icon */
.icon-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #f5f5f5; /* Light gray background */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.icon-circle .fa {
    font-size: 14px;
    color: #555;
}

/* Hover Effects */
.back-link:hover {
    text-decoration: none;
    color: #2d7524; /* Your Active Tab Green */
}

.back-link:hover .icon-circle {
    background-color: #e8f5e9; /* Very light green tint */
    color: #2d7524;
}

.back-link:hover .icon-circle .fa {
    color: #2d7524;
}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>recognition_feed</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  element.on('click', function (event) {
    var button = $(event.target).closest('[data-toggle-comments-for]');
    if (button.length === 0) return;

    var recognitionId = button.data('toggle-comments-for');
    if (!recognitionId) return;

    // var commentsSection = element.find('.comments-section[data-comment-input-for-parent="' + recognitionId + '"]');

    // If comments are being hidden, don't scroll
    var recognition = scope.c.data.filteredRecognitions.find(r => r.id === recognitionId);
    if (!recognition || !recognition.showComments) return;

    // Wait until after the slide animation is complete (400ms)
    setTimeout(function () {
      var input = element.find('[data-comment-input-for="' + recognitionId + '"]');
      if (input.length && input.is(':visible')) {
        // Only scroll if the input is not already fully in view
        var rect = input[0].getBoundingClientRect();
        var isInView = (
          rect.top >= 0 &&
          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
        );

        if (!isInView) {
          input[0].scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
          });
        }

        // Focus on comment after scroll for accessibility
        input.focus();
      }
    }, 400);
  });
}]]></link>
        <name>Recognition Feed</name>
        <option_schema>[{"hint":"Number of records displayed in a page.","name":"limit","section":"Data","default_value":"15","label":"Record Limit","type":"integer"}]</option_schema>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  initializeFilters();

  if (input && input.action == 'getFeed') {
    let currentFeed = input.feedType || 'you';
    let limit = parseInt(input.limit, 10) || 15;
    let offset = parseInt(input.offset, 10) || 0;
    let filters = input.filters || {};

    const recognitionDAO = new x_1794402_peerce_0.RecognitionDAO();

    data.recognitions =
      recognitionDAO.getRecognitionsForFeed(
        currentFeed,
        limit,
        offset,
        filters
      ) || [];

    // const currentUserId = gs.getUserID();

    // recognitions.forEach((rec) => {
    //   // Display 'You' instead of the current user's name in the feed
    //   if (rec.senderId === currentUserId) rec.senderDisplay = 'You';

    //   // If current user is among the recipients, replace their name with 'You' and move to the front of the list
    //   if (rec.recipientIds && rec.recipients) {
    //     const currentUserIndex = rec.recipientIds.indexOf(currentUserId);
    //     if (currentUserIndex > -1) {
    //       rec.recipients.splice(currentUserIndex, 1);
    //       rec.recipients.unshift('You');
    //     }
    //   }
    // });

    // data.recognitions = recognitions;
    return;
  }

  if (input && input.action == 'get_single_recognition') {
    data.singleRecognition = new x_1794402_peerce_0.RecognitionDAO().getRecognitionById(input.recognitionId);
    return;
  }

  if (input && input.action == 'get_latest_recognition_id') {
    data.payload = null;

    let currentFeed = input.feedType || 'you';
    let limit = 1;
    let offset = 0;
    let filters = input.filters || {};

    // Skip the check if not sorting by newest, as we don't need to show indicator or prepend it
    if (filters.sortOrder !== 'newest') return;

    let recognitionDAO = new x_1794402_peerce_0.RecognitionDAO();

    const latestRecognitions =
      recognitionDAO.getRecognitionsForFeed(currentFeed, limit, offset, filters) || [];

    // If no recognitions found, exit early
    if (latestRecognitions.length === 0) return;

    const latestRecognition = latestRecognitions[0];

    if (latestRecognition.id !== input.currentTopId) {
      data.payload = {
        newRecognition: latestRecognition,
        isSelf: latestRecognition.senderId === gs.getUserID()
      };
    }

    return;
  }


  if (input && input.action == 'toggle_recognition_reaction') {
    const recognitionId = input.recognitionId;

    data.toggleReactionSuccess = new x_1794402_peerce_0.RecognitionDAO().toggleRecognitionReaction(recognitionId, gs.getUserID());
    return;
  }

  if (input && input.action === 'toggle_comment_reaction') {
    const commentId = input.commentId;
    const recognitionId = input.recognitionId;

    data.toggleCommentReactionSuccess = new x_1794402_peerce_0.RecognitionDAO().toggleCommentReaction(commentId, gs.getUserID(), recognitionId);
    return;
  }

  if (input && input.action == 'add_comment') {
    const recognitionId = input.recognitionId;
    const commentText = input.commentText;
    const currentUserId = gs.getUserID();


    data.newComment = new x_1794402_peerce_0.RecognitionDAO().addRecognitionComment(recognitionId, commentText, currentUserId);
    return;
  }

  function initializeFilters() {
    data.activityFilterWidget = $sp.getWidget('single-select-filter', {
      title: 'Activity',
      eventName: 'activity.filter.updated',
      choices: [{
        display: 'All',
        value: 'all'
      },
      {
        display: 'Sent',
        value: 'sent'
      },
      {
        display: 'Received',
        value: 'received'
      },
      ],
      initialSelection: 'all',
    });

    data.timeframeFilterWidget = $sp.getWidget(
      'single-select-filter', {
      title: 'Timeframe',
      eventName: 'timeframe.filter.updated',
      choices: [{
        display: 'All Time',
        value: 'all'
      },
      {
        display: 'Last 7 days',
        value: '7'
      },
      {
        display: 'Last 30 days',
        value: '30'
      },
      {
        display: 'Last 90 days',
        value: '90'
      },
      ],
      initialSelection: 'all',
    }
    );

    data.teamMemberFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter', {
      title: 'Team member',
      eventName: 'teammember.filter.updated',
      type: 'dynamic',
      dataConfig: {
        tableName: 'sys_user',
        displayField: 'name',
        valueField: 'sys_id',
        encodedQuery: 'active=true',
      },

      initialSelection: '',
    }
    );

    data.teamFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter', {
      title: 'Team',
      eventName: 'team.filter.updated',
      type: 'dynamic',
      dataConfig: {
        tableName: 'sys_user_group',
        displayField: 'name',
        valueField: 'sys_id',
        encodedQuery: 'active=true',
      },

      initialSelection: '',
    }
    );


    var recognitionOccasions =
      new x_1794402_peerce_0.RecognitionUtils().getRecognitionOccasions();

    data.occasionFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter', {
      title: 'Value',
      eventName: 'occasion.filter.updated',
      choices: recognitionOccasions,
      initialSelection: '',
    }
    );

    data.sortOrderWidget = $sp.getWidget('single-select-filter', {
      title: '',
      eventName: 'sort.order.updated',
      choices: [{
        display: '<i class="fa fa-sort-amount-desc"></i>',
        value: 'newest',
      },
      {
        display: '<i class="fa fa-sort-amount-asc"></i>',
        value: 'oldest',
      },
      ],
      initialSelection: 'newest',
    });
  }
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 13:19:41</sys_created_on>
        <sys_id>09377deec39b621075ea722ed4013146</sys_id>
        <sys_mod_count>750</sys_mod_count>
        <sys_name>Recognition Feed</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy/>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sp_widget_09377deec39b621075ea722ed4013146</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-11-23 12:47:01</sys_updated_on>
        <template><![CDATA[<main>
  <div class="panel panel-primary">
    <section class="panel-heading">
      <h3 class="panel-title">
        <strong>Recognition activity feed</strong>
      </h3>
    </section>

    <nav>
      <ul class="nav nav-tabs">
        <li role="presentation" ng-class="{active: c.activeTab=='you'}">
          <a href="" ng-click="c.setTab('you')">You</a>
        </li>

        <li role="presentation" ng-class="{active: c.activeTab=='team'}">
          <a href="" ng-click="c.setTab('team')">Team</a>
        </li>

        <li role="presentation" ng-class="{active: c.activeTab=='all'}">
          <a href="" ng-click="c.setTab('all')">All</a>
        </li>

        <li class="pull-right">
          <a href="" ng-click="!c.isLoading && applyFiltersAndReload()" title="Refresh feed"
            class="btn btn-default btn-sm refresh-btn" ng-class="{'is-loading': c.isLoading}">
            <i class="fa fa-refresh" ng-class="{'fa-spin': c.isLoading}" aria-hidden="true"></i>
            <span class="sr-only">Refresh</span>
          </a>
        </li>
      </ul>
    </nav>

    <div ng-if="!c.singleRecognitionMode">
      <div class="controls-bar">
        <div class="filters">
          <span>Filter by: </span>

          <div class="filter-wrapper" ng-show="c.activeTab=='you'">
            <sp-widget widget="c.data.activityFilterWidget"></sp-widget>
          </div>

          <div class="filter-wrapper" ng-show="c.activeTab!='you'">
            <sp-widget widget="c.data.teamMemberFilterWidget"></sp-widget>
          </div>
          <div class="filter-wrapper" ng-show="c.activeTab!='you'">
            <sp-widget widget="c.data.teamFilterWidget"></sp-widget>
          </div>

          <div class="filter-wrapper">
            <sp-widget widget="c.data.timeframeFilterWidget"></sp-widget>
          </div>

          <div class="filter-wrapper">
            <sp-widget widget="c.data.occasionFilterWidget"></sp-widget>
          </div>

          <a href ng-click="c.resetFilters()" ng-show="c.hasActiveFilters()" class="reset-link"
            title="Reset filters">↺</a>
        </div>

        <div class="filter-wrapper">
          <sp-widget widget="c.data.sortOrderWidget"></sp-widget>
        </div>
      </div>

      <div class="alert refresh-indicator is-sticky" ng-if="c.showRefreshIndicator" aria-live="polite">
        <div class="refresh-indicator-content">
          <i class="fa fa-bell-o refresh-icon" aria-hidden="true"></i>
          New recognition available!
        </div>
        <div class="refresh-indicator-actions">
          <button class="btn btn-xs btn-primary" ng-click="c.refreshAndShow()">Refresh</button>
          <button type="button" class="close" ng-click="c.showRefreshIndicator = false"
            aria-label="Dismiss">&times;</button>
        </div>
      </div>

      <!-- List group -->
      <section class="feed-container">

        <div ng-if="c.isLoading" class="feed-loading-overlay">
          <i class="fa fa-spinner fa-spin fa-2x text-muted"></i>
        </div>

        <ul class="list-group feed-content" ng-class="{'content-faded': c.isLoading}">
          <li ng-repeat="recognition in c.data.filteredRecognitions track by recognition.id"
            class="list-group-item feed-content-item">

            <div ng-include="'recognition-card'"></div>

          </li>

          <li class="text-center" ng-if="c.data.filteredRecognitions.length > 0">
            <div class="well well-sm text-center mb-0 feed-footer">
              <p class="text-muted small">
                Showing
                <strong>{{c.data.filteredRecognitions.length}}</strong>
                {{c.data.filteredRecognitions.length === 1 ?
                'recognition' : 'recognitions'}}
              </p>

              <div ng-if="c.canLoadMore">
                <button class="btn btn-primary btn-sm" ng-click="c.loadMore()" ng-disabled="c.isLoadingMore">
                  <i class="fa"
                    ng-class="{'fa-spin fa-spinner': c.isLoadingMore, 'fa-arrow-down': !c.isLoadingMore}"></i>
                  {{c.isLoadingMore ? 'Loading...' : 'Load More'}}
                </button>
              </div>

              <p ng-if="!c.canLoadMore && c.data.filteredRecognitions.length > 0"
                class="text-center text-muted small m-0">
                <em>— You've reached the end of the list —</em>
              </p>
            </div>
          </li>

          <li ng-if="!c.data.filteredRecognitions.length" class="list-group-item text-center pt-20 pb-20">
            <div class="p-20">
              <p class="text-muted">
                <i class="fa fa-trophy fa-3x" aria-hidden="true"></i>
              </p>
              <h4 class="text-muted">No Recognitions Found</h4>
              <p class="small text-muted">
                Try adjusting your filters or check back later.
              </p>
            </div>
          </li>
        </ul>
      </section>
    </div>

    <div ng-if="c.singleRecognitionMode" class="single-view-container">

      <div class="sub-nav-header">
        <a href="javascript:void(0)" class="back-link" ng-click="c.goBackToFeed()">
          <div class="icon-circle">
            <i class="fa fa-arrow-left"></i>
          </div>
          <span class="back-text">Back to feed</span>
        </a>
      </div>

      <div ng-if="c.loadingSingle" class="text-center p-20" style="padding: 20px;">
        <i class="fa fa-spinner fa-spin fa-2x text-muted"></i>
      </div>

      <div ng-if="!c.loadingSingle && c.singleRecognition" style="padding: 20px;">
        <div ng-init="recognition = c.singleRecognition">
          <div ng-include="'recognition-card'"></div>
        </div>
      </div>

      <div ng-if="!c.loadingSingle && !c.singleRecognition" class="text-center" style="padding: 40px;">
        <i class="fa fa-exclamation-circle fa-3x text-muted"></i>
        <h4 class="text-muted">Recognition not found</h4>
        <button class="btn btn-default mt-10" ng-click="c.goBackToFeed()">Return to Feed</button>
      </div>

    </div>
  </div>
</main>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>09377deec39b621075ea722ed4013146</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 13:19:41</sys_created_on>
        <sys_id>8d377deec39b621075ea722ed4013148</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-14 13:19:41</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
