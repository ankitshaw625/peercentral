<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function ($scope, $location, spUtil, $timeout, $anchorScroll) {
  var c = this;

  const MAX_RECIPIENTS_TO_SHOW = 2;

  c.currentUserId = $scope.user.sys_id;
  c.currentUserInitials = generateInitials($scope.user.name);

  const userPhoto = $scope.user.photo;
  c.userImage = userPhoto ? userPhoto.split('.')[0] : '';

  c.data.filteredRecognitions = [];
  c.isLoading = false;
  c.isLoadingMore = false;
  c.canLoadMore = true;
  c.showRefreshIndicator = false; // Flag to show the new recognition indicator

  c.offset = 0;
  c.limit = c.options.limit || 10;

  // Default filter state
  c.filters = getDefaultFilters();

  // This function now simply broadcasts a message and then re-fetches the data.
  c.resetFilters = function () {
    // Tell all listening child widgets to reset themselves
    $scope.$broadcast('filters.reset');

    c.showRefreshIndicator = false;

    // Reset the parent's data model
    c.filters = getDefaultFilters();

    // Fetch the new, unfiltered data
    c.setTab(c.activeTab);
  };

  // Check if any filter is active
  c.hasActiveFilters = function () {
    return c.filters.activity !== 'all' ||
      c.filters.timeframe !== 'all' ||
      c.filters.occasions.length > 0 ||
      c.filters.team.length > 0 ||
      c.filters.teamMember.length > 0;
  };


  c.setTab = function (tabName) {
    if (!tabName) return;

    c.data.filteredRecognitions = [];

    c.activeTab = tabName;
    $location.hash(tabName);

    c.offset = 0;
    c.canLoadMore = true;
    c.isLoading = true;
    c.showRefreshIndicator = false;

    loadFeed(tabName, 0, false);
  };

  c.loadMore = function () {
    if (!c.canLoadMore || c.isLoadingMore) return;


    c.isLoadingMore = true;

    loadFeed(c.activeTab, c.offset, true);
  };

  // Hide refresh banner and do a feed refresh
  c.refreshAndShow = function () {
    c.showRefreshIndicator = false;
    c.setTab(c.activeTab);
  };

  // Toggle like/unlike reaction
  c.toggleReaction = function (recognition) {
    const originalReactionState = recognition.currentUserHasReacted;
    const originalReactions = [...recognition.reactions];

    // Only allow reaction animation when like is being added, false by default to prevent animation on initial load
    recognition._allowReactionAnimation = true;

    // Instantly update the UI for responsiveness
    recognition.currentUserHasReacted = !originalReactionState;

    if (originalReactionState) {
      // If this was previously liked, we are removing the like from list
      recognition.reactions =
        recognition.reactions.filter(r => r.userId !== c.currentUserId);
    } else {
      // Otherwise, we are adding a like to the list
      recognition.reactions.push({
        userId: c.currentUserId,
        userName: $scope.user.name,
        created: new Date().toISOString()
      });
    }

    // console.log(recognition.reactions);

    c.server.get({
      action: 'toggle_recognition_reaction',
      recognitionId: recognition.id
    }).then(function (response) {
      // console.log('Toggle reaction response: ', response);

      if (!response.data.toggleReactionSuccess) {
        // In case of failure, revert the UI update
        recognition.currentUserHasReacted = originalReactionState;
        recognition.reactions = originalReactionState;
        // Show feedback to user
        spUtil.addErrorMessage('Your like could not be saved. Please try again.');
      }
    });
  };

  c.toggleCommentReaction = function (comment) {
    const originalReactedState = comment.currentUserHasReacted;
    const originalLikeCount = comment.likeCount;

    // Only allow reaction animation when like is being added, false by default to prevent animation on comment load
    comment._allowReactionAnimation = true;

    // Update the UI immediately for responsiveness
    if (comment.currentUserHasReacted) {
      comment.likeCount--;
    } else {
      comment.likeCount++;
    }

    comment.currentUserHasReacted = !comment.currentUserHasReacted;

    c.server.get({
      action: 'toggle_comment_reaction',
      commentId: comment.id
    }).then(function (response) {
      // Revert the UI update if the server call failed
      if (!response.data.toggleCommentReactionSuccess) {
        comment.currentUserHasReacted = originalReactedState;
        comment.likeCount = originalLikeCount;
        spUtil.addErrorMessage('Your like could not be saved. Please try again.');
      }
    });
  };

  c.toggleComments = function (recognition) {
    recognition.showComments = !recognition.showComments;

  };

  // Submit comment (UI only)
  c.submitComment = function (recognition) {
    const text = (recognition.newCommentText || '').trim();
    if (!text) return;

    const tempId = 'temp-' + Date.now();
    const newComment = {
      id: tempId,
      text: text,
      authorName: $scope.user.name,
      userInitials: c.currentUserInitials,
      userId: c.currentUserSysId,
      timeAgo: 'Just now',
      isSaving: true,
    };

    recognition.comments.push(newComment);
    recognition.newCommentText = '';

    // Make the server call to save the comment
    c.server.get({
      action: 'add_comment',
      recognitionId: recognition.id,
      commentText: text
    }).then(function (response) {
      const newComment = response.data.newComment;
      const commentIndex = recognition.comments.findIndex(c => c.id === tempId);

      if (newComment && commentIndex > -1) {
        // Replace the temporary comment with the real one from the server
        const transformedComment = {
          ...newComment,
          timeAgo: formatTimeAgo(newComment.created),
          authorInitials: generateInitials(newComment.authorName)
        };

        recognition.comments.splice(commentIndex, 1, transformedComment);
        return;
      }

      // If the server fails, remove the temp comment and show an error
      if (commentIndex > -1) recognition.comments.splice(commentIndex, 1);

      spUtil.addErrorMessage('Your comment could not be posted. Please try again.');
      recognition.newCommentText = text;
    });
  };


  var initialTab = $location.hash() || 'you';
  c.setTab(initialTab);

  $scope.$on('$locationChangeSuccess', function () {
    var newTab = $location.hash();

    if (newTab && newTab !== c.activeTab) {
      c.setTab(newTab);
    }
  });

  // Event listeners for filters
  $scope.$on('activity.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.activity !== data.selected.value) {
      c.filters.activity = data.selected.value;
      c.setTab(c.activeTab);
    }
  });

  $scope.$on('teammember.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    c.filters.teamMember = data.selected.map(item => item.value);
    c.setTab(c.activeTab);
  });

  $scope.$on('team.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    c.filters.team = data.selected.map(item => item.value);
    c.setTab(c.activeTab);
  });

  $scope.$on('timeframe.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.timeframe !== data.selected.value) {
      c.filters.timeframe = data.selected.value;
      c.setTab(c.activeTab);
    }
  });

  $scope.$on('occasion.filter.updated', function (event, data) {
    c.showRefreshIndicator = false;

    // For multi-select, data.selected is an array of objects
    c.filters.occasions = data.selected.map(item => item.value);
    c.setTab(c.activeTab);
  });

  $scope.$on('sort.order.updated', function (event, data) {
    c.showRefreshIndicator = false;

    if (c.filters.sortOrder !== data.selected.value) {
      c.filters.sortOrder = data.selected.value;
      c.setTab(c.activeTab);
    }
  });


  let debounceTimer = null;
  function handleRecognitionInsert(response) {

    if (response.data.operation !== 'insert') return;

    $timeout.cancel(debounceTimer);

    debounceTimer = $timeout(function () {
      const isRelevantView = c.filters.sortOrder === 'newest';
      if (!isRelevantView || c.showRefreshIndicator) return;

      const currentTopId = c.data.filteredRecognitions.length > 0 ? c.data.filteredRecognitions[0].id : null;

      // Check if the new recognition is newer than the current top item
      c.server.get({
        action: 'get_latest_recognition_id',
        feedType: c.activeTab,
        filters: c.filters,
        currentTopId: currentTopId
      }).then(function (response) {
        const payload = response.data.payload;

        if (!payload || !payload.newRecognition) return;

        // Show banner for new recognition sent by others
        if (!payload.isSelf) {
          c.showRefreshIndicator = true;
          return
        }

        const transformedItem = transformRecognitions([payload.newRecognition])[0];

        // Add a flag for the CSS highlight effect
        transformedItem.isNew = true;
        c.data.filteredRecognitions.unshift(transformedItem);
        c.offset++;

      });

    }, 750); // 750ms debounce

  }

  spUtil.recordWatch($scope, 'x_1794402_peerce_0_peer_recognition', '', handleRecognitionInsert);


  function getDefaultFilters() {
    return {
      activity: 'all',
      timeframe: 'all',
      occasions: [],
      sortOrder: 'newest',
      team: [],
      teamMember: []
    };
  }

  function loadFeed(feedType, offset, append) {

    c.server.get({ feedType, limit: c.limit, offset, filters: c.filters, action: 'getFeed' })
      .then(function (response) {
        const newRecognitions = transformRecognitions(response.data.recognitions || []);

        if (append) {
          c.data.filteredRecognitions = c.data.filteredRecognitions.concat(newRecognitions);
        } else {
          c.data.filteredRecognitions = newRecognitions;
        }

        // Update the offset
        c.offset = offset + newRecognitions.length;

        // If we got fewer than the limit, no more records left to load
        c.canLoadMore = newRecognitions.length >= c.limit;

      })
      .catch(function (error) {
        console.error('Failed to load feed:', error);
        if (!append) c.data.filteredRecognitions = [];

      }).finally(function () {
        c.isLoading = false;
        c.isLoadingMore = false;
      });
  }

  function transformRecognitions(recognitions) {

    return recognitions.map(function (rec) {
      const transformedComments = (rec.comments || []).map(function (comment) {
        return {
          ...comment,
          timeAgo: formatTimeAgo(comment.created),
          authorInitials: generateInitials(comment.authorName),
          _allowReactionAnimation: false
        };
      });

      const finalRecipients = rec.recipients || [];
      let visibleRecipients = [];
      let remainingCount = 0;
      let remainingRecipientsTooltip = '';

      if (finalRecipients.length > MAX_RECIPIENTS_TO_SHOW) {
        visibleRecipients = finalRecipients.slice(0, MAX_RECIPIENTS_TO_SHOW);
        remainingCount = finalRecipients.length - MAX_RECIPIENTS_TO_SHOW;
        remainingRecipientsTooltip = finalRecipients.slice(MAX_RECIPIENTS_TO_SHOW).join('\n');
      } else {
        visibleRecipients = finalRecipients;
      }

      return {
        ...rec,
        senderInitials: generateInitials(rec.senderDisplay),
        timeAgo: formatTimeAgo(rec.createdOn),

        comments: transformedComments,
        showComments: false,
        newCommentText: '',
        _allowReactionAnimation: false,

        visibleRecipients: visibleRecipients,
        remainingCount: remainingCount,
        remainingRecipientsTooltip: remainingRecipientsTooltip
      };
    });
  }

  function generateInitials(name) {
    if (!name) return '?';

    return name.split(/\s+/)
      .map(part => part[0] ? part[0].toUpperCase() : '')
      .join('')
      .substring(0, 2) || '?';
  }


  function formatTimeAgo(dateTime) {
    if (!dateTime) return '';

    var m = moment(dateTime, "YYYY-MM-DD HH:mm:ss");

    return m.fromNow();
  }


  moment.updateLocale('en', {
    relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    }
  });
};]]></client_script>
        <controller_as>c</controller_as>
        <css>li {
    list-style-type: none;
}

.nav-tabs li a:hover {
    cursor: pointer;
}

.nav-tabs &gt; li &gt; a:focus,
.nav-tabs &gt; li &gt; a:active {
    outline: none;
    box-shadow: none;
}

.nav-tabs &gt; li.active &gt; a {
    border: none;
    border-bottom: 0.2rem solid #2d7524;
}

.refresh-btn {
    border-bottom: none;
}

.refresh-btn .fa-refresh {
    font-size: 18px !important;
    color: #666;
    transition: transform 0.1s ease;
}

.refresh-btn:active .fa-refresh {
    transform: scale(0.9);
}

.refresh-btn:focus,
.refresh-btn:active {
    outline: none;
    box-shadow: none !important;
    background-color: transparent !important;
    border-color: transparent !important;
}
/* ───────────────────────────────
  Control Bar
  ─────────────────────────────── */
.controls-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: #fff;
}

.filters {
    display: flex;
    gap: 12px; /* Increased gap for better spacing */
    align-items: center;
}

/* This is a new class for spacing our widgets */
.filter-wrapper {
    display: inline-block;
}

/* ───────────────────────────────
  Reset Link
  ─────────────────────────────── */
.reset-link {
    color: #999;
    text-decoration: none;
    margin-left: 6px;
    line-height: 1;
}

.reset-link:hover {
    color: #2d7524;
}

/* This container is the positioning anchor for the overlay */
.feed-container {
    position: relative;
    scroll-behavior: smooth;
}

/* This is the spinner overlay itself */
.feed-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    display: flex;
    justify-content: center;

    align-items: flex-start;

    padding-top: 50px;

    background: white;
}

/* New recognition banner styles */
.refresh-indicator {
    background-color: #eef6f8;
    border: 1px solid #cce6ec;
    border-radius: 4px;
    color: #005f79;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    margin: 0;
}

.refresh-indicator.is-sticky {
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    z-index: 1020;
    border-radius: 0;
    border-left: none;
    border-right: none;
    border-top: none;
}

.refresh-indicator-content {
    display: flex;
    align-items: center;
    flex-grow: 1;
}

.refresh-indicator-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}

.refresh-icon {
    margin-right: 8px;
    font-size: 16px;
    color: #0080a3;
}

.refresh-indicator .close {
    font-size: 20px;
    line-height: 1;
    opacity: 0.6;
    color: #005f79;
    text-shadow: none;
    padding: 0;
    margin-left: 10px;
}

.refresh-indicator .close:hover {
    opacity: 1;
    color: #000;
}

.refresh-indicator .btn-primary {
    background-color: #0080a3;
    border-color: #0080a3;
    color: #fff;
    font-weight: 600;
    padding: 4px 10px;
    font-size: 12px;
}

.refresh-indicator .btn-primary:hover {
    background-color: #006a88;
    border-color: #006a88;
}

/* This is the list of recognitions */
.feed-content {
    opacity: 1;
    transition: opacity 0.4s linear;
}

.feed-content-item {
    list-style-type: none;
    border: none;
}

.feed-footer {
    border: none;
    background: inherit;
}

.recognition-container {
    border: 1px solid #ddd;
    padding: 10px;
    border-radius: 2px;
}

/* This class is applied to the list when the spinner is active */
.feed-content.content-faded {
    opacity: 0.5;
    pointer-events: none;
}

.new-badge {
    margin-right: 8px;
    vertical-align: middle;
}

.recognition-indicators abbr {
    display: inline-block;
    cursor: pointer;
}

.private-indicator {
    color: #7b6ea2;
}

.team-indicator {
    color: #007bff;
}

.occasion-tag {
    font-size: 1.2rem;
    border-radius: 3px;
}

/* Main interaction row */
.interaction-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-top: 1px solid #eee;
    margin-top: 12px;
}

/* Left group: Like &amp; Comment */
.action-group {
    display: flex;
    gap: 16px;
}

.action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background: none;
    border: none;
    color: #666;
    font-size: 14px;
    cursor: pointer;
    transition: color 0.2s;
    padding: 4px 8px;
    border-radius: 4px;
}

.action-btn:hover {
    background-color: #f8f9fa;
    color: #1955be;
}

.action-btn.active {
    color: #1955be;
}

.action-btn .fa {
    font-size: 14px;
}

.action-btn:focus {
    outline: 0;
    box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.05);
}

@keyframes like-pop {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.4); /* Grow bigger */
    }
    100% {
        transform: scale(1); /* Return to normal size */
    }
}

.action-btn.can-animate.active .fa-thumbs-up {
    animation: like-pop 0.3s ease-in-out;
}

/* Count badge — small pill */
.count-badge {
    background: #e9ecef;
    color: #495057;
    border-radius: 10px;
    padding: 0 6px;
    font-size: 12px;
    min-width: 18px;
    text-align: center;
    margin-left: 4px;
}

/* Icon sizing for thumbs-up in count */
.icon-small {
    font-size: 12px;
    color: #666;
}

/* Right side: reaction count + reply link */
.meta-info {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #666;
}

.icon-small {
    font-size: 12px;
    color: #666; /* or #495057 for slightly darker */
}

.meta-info .reaction-count {
    color: #666;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
}

.reply-link {
    color: #1955be;
    cursor: pointer;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: background-color 0.2s;
}

.reply-link:hover {
    background-color: #f0f8ff;
    text-decoration: none;
}

/* Indicator icon — down arrow in blue circle */
.indicator-icon {
    font-size: 10px;
    color: #1955be;
    background: #e0f0ff;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
}

/* Comment input below buttons */
.comment-input-container {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #f0f0f0;
}

.comment-input-container .form-control {
    font-size: 14px;
    height: 32px;
}

.comment-input-container .btn {
    height: 32px;
}

.comment-input-container .btn-link {
    font-size: 18px;
    padding: 2px 6px;
    margin-left: 4px;
}

/* Match recognition container styling */
.comment-item {
    background-color: #fafafa;
    border: 1px solid #ddd;
    border-radius: 2px;
    padding: 15px 10px;
    font-size: 14px; /* Match recognition body */
    color: #333; /* Default text color like recognition */
}

.comment-item.is-saving {
    opacity: 0.6;
}

.comment-body {
    /* Remove any previous border or background */
    border: none;
    background: none;
    padding: 0;
}

.comment-body .media-heading {
    display: inline-block;
}

.comment-text {
    margin: 10px 0;
}

/* New container for the modern comment input */
.comment-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

.comment-input-wrapper {
    flex-grow: 1; /* Allows the input to take up the remaining space */
    position: relative;
}

/* Style the form-control within our new container */
.comment-input-container .form-control {
    background-color: #f0f2f5; /* A soft, modern gray */
    border: 1px solid #f0f2f5;
    border-radius: 18px; /* Creates the pill shape */
    padding: 6px 15px;
    height: 36px; /* A slightly taller input */
    line-height: 1.5;
    box-shadow: none;
    transition: border-color 0.2s ease-in-out;
}

/* Add a clear focus state for accessibility and better UX */
.comment-input-container .form-control:focus {
    background-color: #fff;
    border-color: #1955be; /* A highlight color */
    box-shadow: none;
}

.comment-input-wrapper {
    flex-grow: 1;
    position: relative; /* Required for absolute positioning of the child button */
}

.btn-send {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    padding: 0 8px;
    color: #1955be;
    font-size: 16px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
}

.btn-send:hover {
    opacity: 1;
}

/* --- START: NEW NG-ANIMATE STYLES for NG-HIDE --- */

/* Base style for the element */
.slide-animation {
    /* Set a transition on max-height */
    transition: max-height 0.4s ease-in-out;
    overflow: hidden;
}

/* This class is added when the element is BEING HIDDEN */
.slide-animation.ng-hide-add {
    /* Start the animation from its full height */
    max-height: 500px; /* Use a value larger than any possible content height */
}
.slide-animation.ng-hide-add.ng-hide-add-active {
    /* End the animation at zero height */
    max-height: 0;
}

/* This class is added when the element is BEING SHOWN */
.slide-animation.ng-hide-remove {
    /* Start the animation from zero height */
    max-height: 0;
}
.slide-animation.ng-hide-remove.ng-hide-remove-active {
    /* End the animation at its full height */
    max-height: 500px; /* Use a value larger than any possible content height */
}

/* --- END: NEW NG-ANIMATE STYLES --- */
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>recognition_feed</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  element.on('click', function (event) {
    var button = $(event.target).closest('[data-toggle-comments-for]');
    if (button.length === 0) return;

    var recognitionId = button.data('toggle-comments-for');
    if (!recognitionId) return;

    var commentsSection = element.find('.comments-section[data-comment-input-for-parent="' + recognitionId + '"]');
    // We'll add a data attr to the comments-section for easier targeting (see note below)

    // If comments are being hidden, don't scroll
    var recognition = scope.c.data.filteredRecognitions.find(r => r.id === recognitionId);
    if (!recognition || !recognition.showComments) return;

    // Wait until *after* the slide animation completes (400ms as defined in CSS)
    setTimeout(function () {
      var input = element.find('[data-comment-input-for="' + recognitionId + '"]');
      if (input.length && input.is(':visible')) {
        // Only scroll if the input is not already fully in view
        var rect = input[0].getBoundingClientRect();
        var isInView = (
          rect.top >= 0 &&
          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
        );

        if (!isInView) {
          input[0].scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
          });
        }

        // Focus after scroll for accessibility
        input.focus();
      }
    }, 400);
  });
}]]></link>
        <name>Recognition Feed</name>
        <option_schema>[{"hint":"Number of records displayed in a page.","name":"limit","section":"Data","default_value":"15","label":"Record Limit","type":"integer"}]</option_schema>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  initializeFilters();

  if (input && input.action == 'getFeed') {
    let currentFeed = input.feedType || 'you';
    let limit = parseInt(input.limit, 10) || 15;
    let offset = parseInt(input.offset, 10) || 0;
    let filters = input.filters || {};

    let recognitionDAO = new x_1794402_peerce_0.RecognitionDAO();

    const recognitions =
      recognitionDAO.getRecognitionsForFeed(
        currentFeed,
        limit,
        offset,
        filters
      ) || [];

    const currentUserId = gs.getUserID();

    recognitions.forEach((rec) => {
      // Display 'You' instead of the current user's name in the feed
      if (rec.senderId === currentUserId) rec.senderDisplay = 'You';

      // If current user is among the recipients, replace their name with 'You' and move to the front of the list
      if (rec.recipientIds && rec.recipients) {
        const currentUserIndex = rec.recipientIds.indexOf(currentUserId);
        if (currentUserIndex > -1) {
          rec.recipients.splice(currentUserIndex, 1);
          rec.recipients.unshift('You');
        }
      }
    });

    data.recognitions = recognitions;
  }

  if (input && input.action == 'get_latest_recognition_id') {
    data.payload = null;

    let currentFeed = input.feedType || 'you';
    let limit = 1;
    let offset = 0;
    let filters = input.filters || {};

    // Skip the check if not sorting by newest, as we don't need to show indicator or prepend it
    if (filters.sortOrder !== 'newest') return;

    let recognitionDAO = new x_1794402_peerce_0.RecognitionDAO();

    const latestRecognitions =
      recognitionDAO.getRecognitionsForFeed(currentFeed, limit, offset, filters) || [];

    // If no recognitions found, exit early
    if (latestRecognitions.length === 0) return;

    const latestRecognition = latestRecognitions[0];

    if (latestRecognition.id !== input.currentTopId) {
      data.payload = {
        newRecognition: latestRecognition,
        isSelf: latestRecognition.senderId === gs.getUserID()
      };
    }

    // data.latestRecognitionId = latestRecognition.length > 0 ? latestRecognition[0].id : null;
  }


  if (input && input.action == 'toggle_recognition_reaction') {
    const recognitionId = input.recognitionId;

    data.toggleReactionSuccess = new x_1794402_peerce_0.RecognitionDAO().toggleRecognitionReaction(recognitionId, gs.getUserID());
  }

  if (input && input.action === 'toggle_comment_reaction') {
    const commentId = input.commentId;

    data.toggleCommentReactionSuccess = new x_1794402_peerce_0.RecognitionDAO().toggleCommentReaction(commentId, gs.getUserID());
  }

  if (input && input.action == 'add_comment') {
    const recognitionId = input.recognitionId;
    const commentText = input.commentText;
    const currentUserId = gs.getUserID();


    data.newComment = new x_1794402_peerce_0.RecognitionDAO().addRecognitionComment(recognitionId, commentText, currentUserId);
  }

  function initializeFilters() {
    data.activityFilterWidget = $sp.getWidget('single-select-filter', {
      title: 'Activity',
      eventName: 'activity.filter.updated',
      choices: [
        { display: 'All', value: 'all' },
        { display: 'Sent', value: 'sent' },
        { display: 'Received', value: 'received' },
      ],
      initialSelection: 'all',
    });

    data.timeframeFilterWidget = $sp.getWidget(
      'single-select-filter',
      {
        title: 'Timeframe',
        eventName: 'timeframe.filter.updated',
        choices: [
          { display: 'All Time', value: 'all' },
          { display: 'Last 7 days', value: '7' },
          { display: 'Last 30 days', value: '30' },
          { display: 'Last 90 days', value: '90' },
        ],
        initialSelection: 'all',
      }
    );

    data.teamMemberFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter',
      {
        title: 'Team member',
        eventName: 'teammember.filter.updated',
        type: 'dynamic',
        dataConfig: {
          tableName: 'sys_user',
          displayField: 'name',
          valueField: 'sys_id',
          encodedQuery: 'active=true',
        },

        initialSelection: '',
      }
    );

    data.teamFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter',
      {
        title: 'Team',
        eventName: 'team.filter.updated',
        type: 'dynamic',
        dataConfig: {
          tableName: 'sys_user_group',
          displayField: 'name',
          valueField: 'sys_id',
          encodedQuery: 'active=true',
        },

        initialSelection: '',
      }
    );


    var recognitionOccasions =
      new x_1794402_peerce_0.RecognitionUtils().getRecognitionOccasions();

    data.occasionFilterWidget = $sp.getWidget(
      'multi-select-slushbucket-filter',
      {
        title: 'Value',
        eventName: 'occasion.filter.updated',
        choices: recognitionOccasions,
        initialSelection: '',
      }
    );

    data.sortOrderWidget = $sp.getWidget('single-select-filter', {
      title: '',
      eventName: 'sort.order.updated',
      choices: [
        {
          display: '<i class="fa fa-sort-amount-desc"></i>',
          value: 'newest',
        },
        {
          display: '<i class="fa fa-sort-amount-asc"></i>',
          value: 'oldest',
        },
      ],
      initialSelection: 'newest',
    });
  }
})();
]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 13:19:41</sys_created_on>
        <sys_id>09377deec39b621075ea722ed4013146</sys_id>
        <sys_mod_count>710</sys_mod_count>
        <sys_name>Recognition Feed</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy/>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sp_widget_09377deec39b621075ea722ed4013146</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-20 07:53:56</sys_updated_on>
        <template><![CDATA[<main>
  <div class="panel panel-primary">
    <!-- Default panel contents -->
    <section class="panel-heading">
      <h3 class="panel-title">
        <strong>Recognition activity feed</strong>
      </h3>
    </section>

    <nav>
      <ul class="nav nav-tabs">
        <li role="presentation" ng-class="{active: c.activeTab=='you'}">
          <a href="" ng-click="c.setTab('you')">You</a>
        </li>

        <li role="presentation" ng-class="{active: c.activeTab=='team'}">
          <a href="" ng-click="c.setTab('team')">Team</a>
        </li>

        <li role="presentation" ng-class="{active: c.activeTab=='all'}">
          <a href="" ng-click="c.setTab('all')">All</a>
        </li>

        <li class="pull-right">
          <a href="" ng-click="!c.isLoading && c.setTab(c.activeTab)" title="Refresh feed"
            class="btn btn-default btn-sm refresh-btn" ng-class="{'is-loading': c.isLoading}">
            <i class="fa fa-refresh" ng-class="{'fa-spin': c.isLoading}" aria-hidden="true"></i>
            <span class="sr-only">Refresh</span>
          </a>
        </li>
      </ul>
    </nav>

    <div class="controls-bar">
      <div class="filters">
        <span>Filter by: </span>

        <div class="filter-wrapper" ng-show="c.activeTab=='you'">
          <sp-widget widget="c.data.activityFilterWidget"></sp-widget>
        </div>

        <div class="filter-wrapper" ng-show="c.activeTab!='you'">
          <sp-widget widget="c.data.teamMemberFilterWidget"></sp-widget>
        </div>
        <div class="filter-wrapper" ng-show="c.activeTab!='you'">
          <sp-widget widget="c.data.teamFilterWidget"></sp-widget>
        </div>

        <div class="filter-wrapper">
          <sp-widget widget="c.data.timeframeFilterWidget"></sp-widget>
        </div>

        <div class="filter-wrapper">
          <sp-widget widget="c.data.occasionFilterWidget"></sp-widget>
        </div>

        <a href ng-click="c.resetFilters()" ng-show="c.hasActiveFilters()" class="reset-link"
          title="Reset filters">↺</a>
      </div>

      <div class="filter-wrapper">
        <sp-widget widget="c.data.sortOrderWidget"></sp-widget>
      </div>
    </div>



    <div class="alert refresh-indicator is-sticky" ng-if="c.showRefreshIndicator" aria-live="polite">
      <div class="refresh-indicator-content">
        <i class="fa fa-bell-o refresh-icon" aria-hidden="true"></i>
        New recognition available!
      </div>
      <div class="refresh-indicator-actions">
        <button class="btn btn-xs btn-primary" ng-click="c.refreshAndShow()">Refresh</button>
        <button type="button" class="close" ng-click="c.showRefreshIndicator = false"
          aria-label="Dismiss">&times;</button>
      </div>
    </div>

    <!-- List group -->
    <section class="feed-container">

      <div ng-if="c.isLoading" class="feed-loading-overlay">
        <i class="fa fa-spinner fa-spin fa-2x text-muted"></i>
      </div>

      <ul class="list-group feed-content" ng-class="{'content-faded': c.isLoading}">
        <li ng-repeat="recognition in c.data.filteredRecognitions track by recognition.id"
          class="list-group-item feed-content-item">
          <article class="media recognition-container">

            <div class="media-left">
              <user-avatar image-id="recognition.senderImageId" initials="recognition.senderInitials"
                user-name="recognition.senderDisplay">
              </user-avatar>
            </div>

            <div class="media-body p-5">
              <h4 class="media-heading">
                <a href>{{recognition.senderDisplay}}</a> gave
                applause to
                <a href>{{recognition.recipients.join(', ')}}</a>

                <small class="text-muted pull-right">
                  <span ng-if="recognition.isNew" class="label label-default new-badge">New</span>
                  {{recognition.timeAgo}}
                </small>
              </h4>

              <span class="recognition-indicators mb-5 pull-right">
                <abbr title="Private Recognition" class="private-indicator initialism ml-10"
                  ng-if="recognition.isPrivate">
                  <i class="fa fa-lock" aria-hidden="true"></i>
                </abbr>

                <abbr title="Team Recognition" class="team-indicator initialism ml-10" ng-if="recognition.isTeam">
                  <i class="fa fa-users" aria-hidden="true"></i>
                </abbr>
              </span>

              <p ng-if="recognition.message" ng-bind-html="recognition.message"></p>

              <span ng-repeat="occasion in recognition.occasions">
                <small class="label label-default occasion-tag" title="{{occasion}}">
                  <strong>{{occasion}}</strong> </small>&nbsp;
              </span>

              <div class="interaction-row">
                <!-- Left: Like & Comment buttons -->
                <div class="action-group">
                  <button class="action-btn" ng-click="c.toggleReaction(recognition)"
                    ng-class="{active: recognition.currentUserHasReacted, 'can-animate': recognition._allowReactionAnimation}"
                    aria-label="{{ recognition.currentUserHasReacted ? 'Unlike' : 'Like' }}">
                    <i class="fa"
                      ng-class="{'fa-thumbs-up': recognition.currentUserHasReacted,'fa-thumbs-o-up': !recognition.currentUserHasReacted}"></i>
                    <span>Like</span>
                  </button>

                  <button class="action-btn" ng-click="c.toggleComments(recognition)"
                    ng-class="{active: recognition.showComments}" data-toggle-comments-for="{{::recognition.id}}">
                    <i class=" fa"
                      ng-class="{'fa-comment': recognition.showComments, 'fa-comment-o': !recognition.showComments}"></i>
                    <span>
                      {{ recognition.comments.length > 0 ? recognition.comments.length + ' Comment' +
                      (recognition.comments.length > 1 ?'s' : '') : 'Comment' }}
                    </span>
                  </button>

                </div>


                <div class="meta-info">
                  <span class="reaction-count" ng-if="recognition.reactions.length > 0">
                    {{ recognition.reactions.length }} <i class="fa fa-thumbs-o-up icon-small"></i>
                  </span>

                </div>

              </div>

              <div class="comments-section slide-animation" ng-show="recognition.showComments"
                data-comment-input-for-parent="{{::recognition.id}}">
                <div ng-if="recognition.comments.length > 0" class="comments-list mt-20">
                  <article ng-repeat="comment in recognition.comments" class="comment-item media"
                    ng-class="{'is-saving': comment.isSaving}">
                    <div class="media-left">
                      <user-avatar image-id="comment.authorImage" initials="comment.authorInitials"
                        user-name="comment.authorName" class="avatar-sm"></user-avatar>
                    </div>

                    <div class="media-body comment-body">
                      <h4 class="media-heading"><a href="" class="ng-binding">{{comment.authorName}}</a></h4>
                      <span class="text-muted pull-right">{{comment.timeAgo}}</span>
                      <p class="comment-text">{{comment.text}}</p>


                      <div class="interaction-row">
                        <!-- Left: Like & Comment buttons -->
                        <div class="action-group">
                          <button class="action-btn" ng-click="c.toggleCommentReaction(comment)"
                            ng-class="{active: comment.currentUserHasReacted, 'can-animate': comment._allowReactionAnimation}"
                            aria-label="{{ comment.currentUserHasReacted ? 'Unlike' : 'Like' }}">
                            <i class="fa"
                              ng-class="{'fa-thumbs-up': comment.currentUserHasReacted,'fa-thumbs-o-up': !comment.currentUserHasReacted}"></i>
                            <span>Like</span>
                          </button>
                        </div>

                        <!-- Right: Total reactions-->
                        <div class="meta-info">
                          <span class="reaction-count" ng-if="comment.likeCount > 0">
                            {{ comment.likeCount }} <i class="fa fa-thumbs-o-up icon-small"></i>
                          </span>
                        </div>

                      </div>
                    </div>
                  </article>
                </div>

                <div class="comment-input-container mt-10">
                  <user-avatar initials="c.currentUserInitials" user-name="c.currentUser.name" image-id="c.userImage"
                    class="avatar-sm"></user-avatar>
                  <div class="comment-input-wrapper">
                    <input type="text" class="form-control" placeholder="Write a comment..."
                      ng-model="recognition.newCommentText"
                      ng-keyup="$event.keyCode === 13 && c.submitComment(recognition)"
                      data-comment-input-for="{{::recognition.id}}">

                    <button class="btn-send" ng-if="recognition.newCommentText.trim()"
                      ng-click="c.submitComment(recognition)" aria-label="Post comment">
                      <i class="fa fa-paper-plane" aria-hidden="true"></i>
                    </button>
                  </div>
                </div>

              </div>

            </div>


          </article>


        </li>

        <li class="text-center" ng-if="c.data.filteredRecognitions.length > 0">
          <div class="well well-sm text-center mb-0 feed-footer">
            <p class="text-muted small">
              Showing
              <strong>{{c.data.filteredRecognitions.length}}</strong>
              {{c.data.filteredRecognitions.length === 1 ?
              'recognition' : 'recognitions'}}
            </p>

            <div ng-if="c.canLoadMore">
              <button class="btn btn-primary btn-sm" ng-click="c.loadMore()" ng-disabled="c.isLoadingMore">
                <i class="fa" ng-class="{'fa-spin fa-spinner': c.isLoadingMore, 'fa-arrow-down': !c.isLoadingMore}"></i>
                {{c.isLoadingMore ? 'Loading...' : 'Load More'}}
              </button>
            </div>

            <p ng-if="!c.canLoadMore && c.data.filteredRecognitions.length > 0"
              class="text-center text-muted small m-0">
              <em>— You've reached the end of the list —</em>
            </p>
          </div>
        </li>

        <li ng-if="!c.data.filteredRecognitions.length" class="list-group-item text-center pt-20 pb-20">
          <div class="p-20">
            <p class="text-muted">
              <i class="fa fa-trophy fa-3x" aria-hidden="true"></i>
            </p>
            <h4 class="text-muted">No Recognitions Found</h4>
            <p class="small text-muted">
              Try adjusting your filters or check back later.
            </p>
          </div>
        </li>
      </ul>
    </section>
  </div>
</main>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>09377deec39b621075ea722ed4013146</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 13:19:41</sys_created_on>
        <sys_id>8d377deec39b621075ea722ed4013148</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-14 13:19:41</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
