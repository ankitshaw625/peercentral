<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_1794402_peerce_0.RecognitionDAO</api_name>
        <caller_access>1</caller_access>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>RecognitionDAO</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * Data Access Object for the Recognition application.
 * Contains modular CRUD methods for both Recognition and Recipient tables,
 * as well as high-level service methods to coordinate them.
 */
var RecognitionDAO = Class.create();
RecognitionDAO.prototype = {
  initialize: function () {
    this.utils = new x_1794402_peerce_0.RecognitionUtils();
    this.currentUserId = gs.getUserID();
  },

  // =======================================================================
  // == Public callable methods
  // =======================================================================

  /**
   * Creates a complete recognition with its recipient(s).
   * @param {object} recognitionData - e.g., { recipient_id: '...', recipient_type: 'user', category_id: '...', message: '...' }
   * @returns {string} The sys_id of the new recognition record.
   */
  createRecognition: function (recognitionData) {
    recognitionData.sender = this.currentUserId;

    var isTeam = recognitionData.isTeam;
    var isPrivate = recognitionData.isPrivate;
    var recognitionSysId = null;

    // Insert a new recognition record
    var grRecognition = new GlideRecord(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognition.newRecord();
    // grRecognition.category = recognitionData.category;

    grRecognition.message = recognitionData.message;
    grRecognition.sender = recognitionData.sender;
    grRecognition.is_team = isTeam;
    grRecognition.is_private = isPrivate;
    grRecognition.notify_to = recognitionData.notifyTo;

    recognitionSysId = grRecognition.insert();

    // Handle error for recognition creation failure
    if (!recognitionSysId) {
      var errorMessage = grRecognition.getLastErrorMessage();

      gs.error(
        'RecognitionDAO: createRecognition failed at recognition creation step. Error: ' +
        errorMessage
      );

      return {
        status: 'failure',
        message: errorMessage,
      };
    }

    var recipients = recognitionData.recipients.split(',');

    for (var i = 0; i < recipients.length; i++) {
      var currentRecipient = recipients[i];

      // Create individual recipients
      var recognitionRecipientSysId = null;
      var grRecognitionRecipient = new GlideRecord(
        'x_1794402_peerce_0_recognition_recipient'
      );

      grRecognitionRecipient.newRecord();
      grRecognitionRecipient.recognition = recognitionSysId;

      if (isTeam) {
        grRecognitionRecipient.recipient_group = currentRecipient;
      } else {
        grRecognitionRecipient.recipient_user = currentRecipient;
      }

      recognitionRecipientSysId = grRecognitionRecipient.insert();

      // Add logs for recipient creation failure
      if (!recognitionRecipientSysId) {
        errorMessage = grRecognitionRecipient.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition recipient creation step. Error: ' +
          errorMessage
        );
      }
    }

    const occasions = recognitionData.category.split(',');

    occasions.forEach((occ) => {
      const appliedOccasionGr = new GlideRecord(
        'x_1794402_peerce_0_applied_recognition_occasion'
      );
      appliedOccasionGr.newRecord();
      appliedOccasionGr.recognition = recognitionSysId;
      appliedOccasionGr.occasion = occ;
      // ⚠️ HACK: ServiceNow sometimes auto-resolves .name here — not guaranteed.
      // Better: Query occasion table or pass display value from UI.
      appliedOccasionGr.occasion_text =
        appliedOccasionGr.occasion.name.toString();
      const recognitionOccasionSysId = appliedOccasionGr.insert();

      // Add logs for recipient creation failure
      if (!recognitionOccasionSysId) {
        errorMessage = appliedOccasionGr.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition occasion creation step. Error: ' +
          errorMessage
        );
      }
    });

    return {
      status: 'success',
      message: 'Recognition created successfully.',
    };
  },

  /**
   * Retrieves a  list of recognition records, including their recipients.
   * @param {number} limit - The number of recognition records to retrieve.
   * @returns {Array<object>} A complete data object for the recognition, or empty array.
   */

  getRecognitionsForFeed: function (feedType, limit, offset, filters) {
    limit = limit || 15;
    offset = offset || 0;

    const recognitions = [];

    const grRecognitions = new GlideRecordSecure(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognitions.orderByDesc('sys_created_on');
    grRecognitions.setLimit(limit);

    this._applyFilter(grRecognitions, feedType, filters);

    grRecognitions.chooseWindow(offset, offset + limit);
    grRecognitions.query();

    // gs.info('Query: ' + grRecognitions.getEncodedQuery());

    // var interactions = {
    //   comments: rec.comments || [
    //     { id: 'temp-1', text: 'Great job!', authorName: 'Alice Johnson', authorInitials: 'AJ', userId: 'user_temp_1', created: '2025-10-01T12:00:00Z', timeAgo: formatTimeAgo('2025-10-01T12:00:00Z'), likeCount: 0, currentUserHasReacted: false },
    //     { id: 'temp-2', text: 'Well deserved!', authorName: 'Bob Lee', authorInitials: 'BL', userId: 'user_temp_2', created: '2025-10-02T15:30:00Z', timeAgo: formatTimeAgo('2025-10-02T15:30:00Z'), likeCount: 1, currentUserHasReacted: true }
    //   ],   // from server (or empty)
    //   currentUserHasReacted: (rec.reactions || []).some(r => r.userId === c.currentUserSysId),
    //   showCommentInput: false,
    //   showCommentList: false,
    //   newCommentText: ''
    // };


    while (grRecognitions.next()) {
      const recognitionSysId = grRecognitions.getUniqueValue();
      const recognitionSender = grRecognitions.getValue('sender');
      const isTeam = grRecognitions.getValue('is_team') == '1';
      const isPrivate = grRecognitions.getValue('is_private') == '1';

      const recognition = {
        senderId: recognitionSender,
        senderDisplay: grRecognitions.getDisplayValue('sender'),
        isPrivate: isPrivate,
        isTeam: isTeam,
        message: grRecognitions.getValue('message'),
        createdOn: grRecognitions.getValue('sys_created_on'),
        recipients: [],
        occasions: [],
        feed: feedType,
        id: recognitionSysId,
        senderImageId: grRecognitions.getElement('sender.photo').getValue(),
        reactions: [],
        comments: [],
        currentUserHasReacted: false
      };

      const recognitionData = this.getRecognitionRecipients(
        recognitionSysId,
        recognition.isTeam
      );

      recognition.recipients = recognitionData.displayNames;

      // // Privacy filter (if not fully handled by ACLs)
      // if (isPrivate && !this.utils.canReadPrivateRecognition(grRecognitions, this.currentUserId)) {
      //     continue;
      // }

      // const recognitionRecipients = recognitionData.userIds;

      // var isCurrentUserRecognition = this.currentUserId == recognitionSender || recognitionRecipients.includes(this.currentUserId);

      // recognition.feed = isCurrentUserRecognition ? 'you' : 'all';

      // if (this.utils.isTeamRecognition(recognitionSender, recognitionRecipients)) {
      //     recognition.feed += ',team';
      // }

      // Get recognition occasions
      recognition.occasions =
        this.getRecognitionOccasions(recognitionSysId);

      // Get recognition reactions
      const reactionData = this.getRecognitionReactions(recognitionSysId);
      recognition.reactions = reactionData.reactions;
      recognition.currentUserHasReacted = reactionData.currentUserHasReacted;

      recognition.comments = this.getRecognitionComments(recognitionSysId);

      // Add recognitions to list
      recognitions.push(recognition);
    }

    return recognitions;
  },

  getRecognitionDetails: function (userId) {
    // Store the original user ID to prevent side effects
    const originalUserId = this.currentUserId;

    try {
      // Temporarily set the currentUserId to the selected user
      this.currentUserId = userId;

      const filters = { sortOrder: 'newest' };
      const limit = 5;
      const offset = 0;

      const recognitions = this.getRecognitionsForFeed('you', limit, offset, filters);

      const recognitionDetails = [];

      recognitions.forEach(rec => {
        if (rec.isTeam) return;

        const isSent = (rec.senderId === userId);

        recognitionDetails.push({
          type: isSent ? 'Sent' : 'Received',
          recipientNames: isSent ? rec.recipients.join(', ') : '',
          senderName: isSent ? '' : rec.senderDisplay,
          message: rec.message,
          timestamp: rec.createdOn,
          occasions: rec.occasions
        });
      });

      return recognitionDetails;
    } finally {
      // Restore the original user ID
      this.currentUserId = originalUserId;
    }
  },

  getRecognitionRecipients: function (recognitionSysId, isTeam) {
    var recipientData = {
      userIds: [],
      displayNames: [],
    };

    var grRecognitionRecipient = new GlideRecord(
      'x_1794402_peerce_0_recognition_recipient'
    );
    grRecognitionRecipient.addQuery('recognition', recognitionSysId);
    // grRecognitionRecipient.order
    grRecognitionRecipient.query();

    while (grRecognitionRecipient.next()) {
      var recipientId = grRecognitionRecipient.getValue('recipient_user');
      var recipientDisplay =
        grRecognitionRecipient.getDisplayValue('recipient_user');

      if (isTeam) {
        recipientId =
          grRecognitionRecipient.getValue('recipient_group');
        recipientDisplay =
          grRecognitionRecipient.getDisplayValue('recipient_group');
      }

      recipientData.userIds.push(recipientId);
      recipientData.displayNames.push(recipientDisplay);
    }

    return recipientData;
  },

  getRecognitionOccasions: function (recognitionSysId) {
    const occasions = [];
    const grAppliedOccasion = new GlideRecord(
      'x_1794402_peerce_0_applied_recognition_occasion'
    );
    grAppliedOccasion.addQuery('recognition', recognitionSysId);
    grAppliedOccasion.query();

    while (grAppliedOccasion.next()) {
      occasions.push(grAppliedOccasion.getValue('occasion_text'));
    }

    return occasions;
  },

  _applyFilter: function (grRecognitions, feedType, filters) {
    // apply sorting order
    if (filters.sortOrder === 'oldest') {
      grRecognitions.orderBy('sys_created_on');
    } else {
      grRecognitions.orderByDesc('sys_created_on');
    }

    // apply feed filters
    switch (feedType) {
      case 'you': {
        if (filters.activity === 'sent') {
          grRecognitions.addQuery('sender', this.currentUserId);
          break;
        }

        const receivedIds = this._getRecognitionIdsForRecipients(
          this.currentUserId
        );

        if (filters.activity === 'received') {
          grRecognitions.addQuery('sys_id', 'IN', receivedIds);
        } else {
          grRecognitions
            .addQuery('sender', this.currentUserId)
            .addOrCondition('sys_id', 'IN', receivedIds);
        }

        break;
      }

      case 'team': {
        let userTeam = this.utils.getUserTeam();

        if (
          !userTeam ||
          !userTeam.combined ||
          !userTeam.combined.length
        ) {
          userTeam = {
            userGroups: [],
            teamMembers: [this.currentUserId],
            combined: [this.currentUserId],
          };
        }

        const teamReceivedIds = this._getRecognitionIdsForRecipients(
          userTeam.teamMembers, userTeam.userGroups
        );

        grRecognitions
          .addQuery('sender', 'IN', userTeam.teamMembers)
          .addOrCondition('sys_id', 'IN', teamReceivedIds);
        break;
      }

      case 'all':
        break;

      default:
        grRecognitions.addQuery('sys_id', '-1');
    }

    // 3. Layer on Additional AND Filters (Refinements)
    if (filters.timeframe && filters.timeframe !== 'all') {
      grRecognitions.addQuery(
        'sys_created_on',
        '>=',
        gs.daysAgo(filters.timeframe)
      );
    }

    if (filters.occasions && filters.occasions.length > 0) {
      const occasionRecognitionIds = this._getRecognitionIdsForOccasions(
        filters.occasions
      );

      // Ensure query doesn't fail if no occasions match
      if (occasionRecognitionIds.length > 0) {
        grRecognitions.addQuery('sys_id', 'IN', occasionRecognitionIds);
      } else {
        grRecognitions.addQuery('sys_id', '-1');
      }
    }

    // Skip the next set of filter if the current feed is you
    if (feedType === 'you') return;

    // Consolidate team/team member users and add the conditions
    let allUserIds = [], allGroupIds = [];

    if (filters.teamMember && filters.teamMember.length > 0) {
      allUserIds = allUserIds.concat(filters.teamMember);
    }

    if (filters.team && filters.team.length > 0) {
      const groupMembers = this.utils.getGroupMembers(filters.team);
      allUserIds = allUserIds.concat(groupMembers);

      allGroupIds = filters.team;
    }

    if (allUserIds.length > 0 || allGroupIds.length > 0) {
      const uniqueUserIds = Array.from(new Set(allUserIds));


      const recipientRecognitionIds = this._getRecognitionIdsForRecipients(uniqueUserIds, allGroupIds);

      grRecognitions
        .addQuery('sender', 'IN', uniqueUserIds)
        .addOrCondition('sys_id', 'IN', recipientRecognitionIds);
    }
  },


  getGraphData: function (occasionIds = [], daysAgo = 0) {
    const userNodes = new Map();
    const edgeCounts = new Map();
    const outDegreeMap = new Map(); // senderId → Set(recipientIds)
    const inDegreeMap = new Map();  // recipientId → Set(senderIds)
    const edges = [];

    // Helper function to create a new node if it doesn't exist
    const ensureNodeExists = (userId, userName) => {
      if (!userNodes.has(userId)) {
        userNodes.set(userId, {
          id: userId,
          label: userName,
          sent: 0,
          received: 0,
          value: 0,
          initials: this.utils.getInitials(userName),
          outDegree: 0,
          inDegree: 0,
        });
      }
    };

    // Query recognition recipients with necessary filters to build nodes and edges
    const recipientGr = new GlideRecordSecure('x_1794402_peerce_0_recognition_recipient');

    if (daysAgo > 0)
      recipientGr.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

    if (Array.isArray(occasionIds) && occasionIds.length > 0) {
      const validRecognitionIds = this._getRecognitionIdsForOccasions(occasionIds);
      recipientGr.addQuery('recognition', 'IN', validRecognitionIds);
    }

    recipientGr.addQuery('recognition.is_team', false);
    recipientGr.addNotNullQuery('recognition.sender');
    recipientGr.addNotNullQuery('recipient_user');
    recipientGr.query();

    while (recipientGr.next()) {
      const senderId = recipientGr.getElement('recognition.sender').getValue();
      const recipientId = recipientGr.getValue('recipient_user');

      if (senderId === recipientId) continue;

      const senderName = recipientGr.getDisplayValue('recognition.sender');
      const recipientName = recipientGr.getDisplayValue('recipient_user');

      // Add nodes if they don't exist
      ensureNodeExists(senderId, senderName);
      ensureNodeExists(recipientId, recipientName);

      const senderNode = userNodes.get(senderId);
      senderNode.sent += 1;
      senderNode.value += 1;

      const recipientNode = userNodes.get(recipientId);
      recipientNode.received += 1;
      recipientNode.value += 1;

      // Build edges, connting sender to recipient
      const key = senderId + '->' + recipientId;
      edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);

      // Build degree maps, count unique connections
      if (!outDegreeMap.has(senderId)) outDegreeMap.set(senderId, new Set());
      if (!inDegreeMap.has(recipientId)) inDegreeMap.set(recipientId, new Set());
      outDegreeMap.get(senderId).add(recipientId);
      inDegreeMap.get(recipientId).add(senderId);
    }

    // If no records were found, return an empty graph
    if (userNodes.size === 0) {
      return { nodes: [], edges: [], groups: [] };
    }

    // Add additional user details (department, photo) to nodes
    const userIds = Array.from(userNodes.keys());
    const uniqueGroups = new Set();
    const grUser = new GlideRecord('sys_user');
    grUser.addQuery('sys_id', 'IN', userIds);
    grUser.query();

    while (grUser.next()) {
      const userId = grUser.getUniqueValue();
      const node = userNodes.get(userId);
      if (node) {
        const department = grUser.getDisplayValue('department') || 'N/A';
        const photo = grUser.getValue('photo');
        node.group = department;
        node.userImage = photo ? 'sys_attachment.do?sys_id=' + photo : '';
        uniqueGroups.add(department);
      }
    }

    // Format edges in the required format with reciprocal info
    const allEdgeKeys = new Set(edgeCounts.keys());
    for (const [key, value] of edgeCounts.entries()) {
      const [fromId, toId] = key.split('->');
      edges.push({
        id: key, from: fromId, to: toId, value: value,
        title: `${value} recognition${value > 1 ? 's' : ''}.`,
        reciprocal: allEdgeKeys.has(toId + '->' + fromId)
      });
    }

    const finalNodes = Array.from(userNodes.values());
    finalNodes.forEach(node => {
      node.outDegree = outDegreeMap.has(node.id) ? outDegreeMap.get(node.id).size : 0;
      node.inDegree = inDegreeMap.has(node.id) ? inDegreeMap.get(node.id).size : 0;
    });

    // Sort and finalize groups
    const sortedGroups = Array.from(uniqueGroups).sort((a, b) => {
      if (a === 'N/A') return 1;
      if (b === 'N/A') return -1;
      return a.localeCompare(b);
    });

    return { nodes: finalNodes, edges: edges, groups: sortedGroups };
  },

  _getRecognitionIdsForOccasions: function (occasionIds) {
    if (typeof occasionIds === 'string') {
      occasionIds = [occasionIds];
    }

    if (!Array.isArray(occasionIds) || occasionIds.length === 0) {
      return [];
    }

    const recognitionIds = [];

    var gaAppliedOccasion = new GlideAggregate('x_1794402_peerce_0_applied_recognition_occasion');
    gaAppliedOccasion.addQuery('occasion', 'IN', occasionIds);
    gaAppliedOccasion.groupBy('recognition');
    gaAppliedOccasion.query();

    while (gaAppliedOccasion.next()) {
      recognitionIds.push(gaAppliedOccasion.getValue('recognition'));
    }

    return recognitionIds;
  },

  _getRecognitionIdsForRecipients: function (userIds, groupIds) {
    if (typeof userIds === 'string') {
      userIds = [userIds];
    }

    const hasUsers = Array.isArray(userIds) && userIds.length > 0;
    const hasGroups = Array.isArray(groupIds) && groupIds.length > 0;

    if (!hasUsers && !hasGroups) {
      return [];
    }

    var recognitionIds = [];

    var gaRecognitionRecipients = new GlideAggregate(
      'x_1794402_peerce_0_recognition_recipient'
    );

    gaRecognitionRecipients.addQuery('recipient_user', 'IN', userIds)
      .addOrCondition('recipient_group', 'IN', groupIds);

    gaRecognitionRecipients.query();

    while (gaRecognitionRecipients.next()) {
      recognitionIds.push(
        gaRecognitionRecipients.getValue('recognition')
      );
    }

    return recognitionIds;
  },


  // CRUD methods for Recognition Interactions

  // Toggles a 'like' interaction for a given recognition.
  toggleRecognitionReaction: function (recognitionId, userId) {
    if (!recognitionId || !userId) {
      return false;
    }

    const interactionGR = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    interactionGR.addQuery('recognition', recognitionId);
    interactionGR.addQuery('user', userId);
    interactionGR.addQuery('type', 'reaction');
    interactionGR.addQuery('reaction', 'like');
    interactionGR.setLimit(1);
    interactionGR.query();

    if (interactionGR.next()) {
      // Delete existing like reaction - unlike action
      return interactionGR.deleteRecord();
    }


    // If no existing like reaction, exists add one
    interactionGR.newRecord();
    interactionGR.setValue('recognition', recognitionId);
    interactionGR.setValue('user', userId);
    interactionGR.setValue('type', 'reaction');
    interactionGR.setValue('reaction', 'like');

    var interactionSysId = interactionGR.insert();

    return interactionSysId !== null;
  },

  getRecognitionReactions: function (recognitionId) {

    const reactions = [];
    let currentUserHasReacted = false;

    const interactionGR = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    interactionGR.addQuery('recognition', recognitionId);
    interactionGR.addQuery('type', 'reaction');
    interactionGR.addQuery('reaction', 'like');
    interactionGR.orderBy('sys_created_on');
    interactionGR.query();

    while (interactionGR.next()) {
      const reactionUserId = interactionGR.getValue('user');

      reactions.push({
        userId: reactionUserId,
        userName: interactionGR.getDisplayValue('user'),
        created: interactionGR.getValue('sys_created_on')
      });

      if (reactionUserId == this.currentUserId)
        currentUserHasReacted = true;

    }

    return { reactions, currentUserHasReacted };
  },

  addRecognitionComment: function (recognitionId, commentText, userId) {
    if (!recognitionId || !commentText || !userId) {
      gs.error('InteractionDAO.createComment: Missing required parameters.');
      return null;
    }

    const grInteractionComment = new GlideRecord('x_1794402_peerce_0_rec_interaction');

    grInteractionComment.newRecord();
    grInteractionComment.setValue('recognition', recognitionId);
    grInteractionComment.setValue('user', userId);
    grInteractionComment.setValue('type', 'comment');
    grInteractionComment.setValue('comment', commentText);

    var newCommentId = grInteractionComment.insert();

    if (!newCommentId) {
      gs.error('RecognitionDAO.addRecognitionComment: Failed to insert comment for recognition ' + recognitionId);
      return null;
    }

    return {
      id: newCommentId,
      text: grInteractionComment.getValue('comment'),
      authorName: grInteractionComment.getDisplayValue('user'),
      userId: userId,
      created: grInteractionComment.getValue('sys_created_on'),
      likeCount: 0
    };
  },

  // Toggles a 'like' interaction for a given comment.
  toggleCommentReaction: function (parentCommentId, userId) {
    if (!parentCommentId || !userId) {
      return false;
    }

    const grCommentReaction = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    grCommentReaction.addQuery('parent', parentCommentId);
    grCommentReaction.addQuery('user', userId);
    grCommentReaction.addQuery('type', 'reaction');
    grCommentReaction.addQuery('reaction', 'like');
    grCommentReaction.setLimit(1);
    grCommentReaction.query();

    if (grCommentReaction.next()) {
      // Delete existing like reaction - unlike action
      return grCommentReaction.deleteRecord();
    }


    // If no existing like reaction, exists add one
    grCommentReaction.newRecord();
    grCommentReaction.setValue('parent', parentCommentId);
    grCommentReaction.setValue('user', userId);
    grCommentReaction.setValue('type', 'reaction');
    grCommentReaction.setValue('reaction', 'like');

    var interactionSysId = grCommentReaction.insert();

    return interactionSysId !== null;
  },

  getRecognitionComments: function (recognitionId) {
    const commentsMap = new Map();

    const grInteractionComments = new GlideRecord('x_1794402_peerce_0_rec_interaction');

    grInteractionComments.addQuery('recognition', recognitionId);
    grInteractionComments.addQuery('type', 'comment');
    grInteractionComments.orderBy('sys_created_on');
    grInteractionComments.query();

    while (grInteractionComments.next()) {
      const commentId = grInteractionComments.getValue('sys_id');

      commentsMap.set(commentId, {
        id: grInteractionComments.getValue('sys_id'),
        text: grInteractionComments.getValue('comment'),
        authorName: grInteractionComments.getDisplayValue('user'),
        userId: grInteractionComments.getValue('user'),
        authorImage: grInteractionComments.getElement('user.photo').getValue(),
        created: grInteractionComments.getValue('sys_created_on'),
        currentUserHasReacted: false,
        likeCount: 0
      });

    }

    // If there're no comments, return early
    if (commentsMap.size === 0) {
      return [];
    }


    // Do a single aggregate query to get like counts for all the comments
    const commentIds = Array.from(commentsMap.keys());
    const gaCommentReactions = new GlideAggregate('x_1794402_peerce_0_rec_interaction');
    gaCommentReactions.addQuery('parent', 'IN', commentIds);
    gaCommentReactions.addQuery('type', 'reaction');
    gaCommentReactions.groupBy('parent');
    gaCommentReactions.addAggregate('COUNT');
    gaCommentReactions.query();

    while (gaCommentReactions.next()) {
      const parentId = gaCommentReactions.getValue('parent');
      const count = gaCommentReactions.getAggregate('COUNT');

      // Retrieve the comment from the map and update its likeCount
      if (commentsMap.has(parentId)) {
        const comment = commentsMap.get(parentId);
        comment.likeCount = parseInt(count, 10);
      }
    }

    // Get the current user's liked comments
    const userLikedComments = new Set();
    const grUserReactions = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    grUserReactions.addQuery('parent', 'IN', commentIds);
    grUserReactions.addQuery('type', 'reaction');
    grUserReactions.addQuery('user', this.currentUserId);
    grUserReactions.query();

    while (grUserReactions.next()) {
      userLikedComments.add(grUserReactions.getValue('parent'));
    }

    commentIds.forEach(commentId => {
      if (userLikedComments.has(commentId))
        commentsMap.get(commentId).currentUserHasReacted = true;

    });

    return Array.from(commentsMap.values());
  },


  // /**
  //  * Retrieves a complete recognition record, including its recipients.
  //  * @param {string} sysId - The sys_id of the recognition to retrieve.
  //  * @returns {object} A complete data object for the recognition, or null.
  //  */
  // getCompleteRecognition: function(sysId) {
  //     var recognition = this._readRecognition(sysId);
  //     if (!recognition)
  //         return null;

  //     recognition.recipients = this._readRecipientsForRecognition(sysId);
  //     return recognition;
  // },

  // /**
  //  * Deletes a complete recognition and its associated recipients.
  //  * @param {string} sysId - The sys_id of the recognition to delete.
  //  * @returns {boolean} True on success.
  //  */
  // deleteCompleteRecognition: function(sysId) {
  //     this._deleteRecipientsForRecognition(sysId);
  //     return this._deleteRecognition(sysId);
  // },

  // // =======================================================================
  // // == Private Helper Methods
  // // =======================================================================

  // _createRecognition: function(data) {

  // },

  // _readRecognition: function(sysId) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (!recGr.get(sysId))
  //         return null;

  //     return {
  //         sys_id: recGr.getUniqueValue(),
  //         message: recGr.getValue('message'),
  //         sender: recGr.getDisplayValue('sender'),
  //         category: recGr.getDisplayValue('category'),
  //         created_on: recGr.getValue('sys_created_on')
  //     };
  // },

  // _updateRecognition: function(sysId, data) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (!recGr.get(sysId))
  //         return false;

  //     for (var key in data) {
  //         if (recGr.isValidField(key))
  //             recGr.setValue(key, data[key]);
  //     }
  //     return recGr.update();
  // },

  // _deleteRecognition: function(sysId) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (recGr.get(sysId))
  //         return recGr.deleteRecord();
  //     return false;
  // },

  // // =======================================================================
  // // == LOW-LEVEL RECIPIENT METHODS (Private)
  // // =======================================================================

  // _readRecipientsForRecognition: function(recognitionSysId) {
  //     var recipients = [];
  //     var recGr = new GlideRecord(this.recipientTable);
  //     recGr.addQuery('recognition', recognitionSysId);
  //     recGr.query();
  //     while (recGr.next()) {
  //         var name = recGr.getDisplayValue('recipient_user') || recGr.getDisplayValue('recipient_group');
  //         recipients.push({
  //             name: name,
  //             sys_id: recGr.getUniqueValue()
  //         });
  //     }
  //     return recipients;
  // },

  // _deleteRecipientsForRecognition: function(recognitionSysId) {
  //     var recGr = new GlideRecord(this.recipientTable);
  //     recGr.addQuery('recognition', recognitionSysId);
  //     recGr.deleteMultiple();
  // },

  type: 'RecognitionDAO',
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-23 11:20:40</sys_created_on>
        <sys_id>afe03b9dc3e3225075ea722ed40131ea</sys_id>
        <sys_mod_count>139</sys_mod_count>
        <sys_name>RecognitionDAO</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sys_script_include_afe03b9dc3e3225075ea722ed40131ea</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-05 17:24:57</sys_updated_on>
    </sys_script_include>
</record_update>
