<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_1794402_peerce_0.RecognitionDAO</api_name>
        <caller_access>1</caller_access>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>RecognitionDAO</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[
var RecognitionDAO = Class.create();
RecognitionDAO.prototype = {
  initialize: function () {
    this.utils = new x_1794402_peerce_0.RecognitionUtils();
    this.currentUserId = gs.getUserID();
  },

  createRecognition: function (recognitionData) {
    recognitionData.sender = this.currentUserId;

    var sourceRecommendationId = recognitionData.sourceRecommendationId;
    var isTeam = recognitionData.isTeam;
    var isPrivate = recognitionData.isPrivate;
    var recognitionSysId = null;

    // Insert a new recognition record
    var grRecognition = new GlideRecord(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognition.newRecord();
    // grRecognition.category = recognitionData.category;

    grRecognition.message = recognitionData.message;
    grRecognition.sender = recognitionData.sender;
    grRecognition.is_team = isTeam;
    grRecognition.is_private = isPrivate;
    grRecognition.notify_to = recognitionData.notifyTo;

    if (sourceRecommendationId)
      grRecognition.source_recommendation = sourceRecommendationId;

    recognitionSysId = grRecognition.insert();

    // Handle error for recognition creation failure
    if (!recognitionSysId) {
      var errorMessage = grRecognition.getLastErrorMessage();

      gs.error(
        'RecognitionDAO: createRecognition failed at recognition creation step. Error: ' +
        errorMessage
      );

      return {
        status: 'failure',
        message: errorMessage,
      };
    }

    // Update the status of the source recommendation if applicable
    if (sourceRecommendationId) {
      const grCurrentRecommendation = new GlideRecord('x_1794402_peerce_0_recomendations');
      grCurrentRecommendation.addQuery('sys_id', sourceRecommendationId);
      grCurrentRecommendation.setLimit(1);
      grCurrentRecommendation.query();

      if (grCurrentRecommendation.next()) {
        grCurrentRecommendation.setValue('status', 'action_taken');
        grCurrentRecommendation.update();
      }
    }

    var recipients = recognitionData.recipients.split(',');

    for (var i = 0; i < recipients.length; i++) {
      var currentRecipient = recipients[i];

      // Create individual recipients
      var recognitionRecipientSysId = null;
      var grRecognitionRecipient = new GlideRecord(
        'x_1794402_peerce_0_recognition_recipient'
      );

      grRecognitionRecipient.newRecord();
      grRecognitionRecipient.recognition = recognitionSysId;

      if (isTeam) {
        grRecognitionRecipient.recipient_group = currentRecipient;
      } else {
        grRecognitionRecipient.recipient_user = currentRecipient;
      }

      recognitionRecipientSysId = grRecognitionRecipient.insert();

      // Add logs for recipient creation failure
      if (!recognitionRecipientSysId) {
        errorMessage = grRecognitionRecipient.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition recipient creation step. Error: ' +
          errorMessage
        );
      }
    }

    const occasions = recognitionData.category.split(',');

    occasions.forEach((occ) => {
      const appliedOccasionGr = new GlideRecord(
        'x_1794402_peerce_0_applied_recognition_occasion'
      );
      appliedOccasionGr.newRecord();
      appliedOccasionGr.recognition = recognitionSysId;
      appliedOccasionGr.occasion = occ;
      // ⚠️ HACK: ServiceNow sometimes auto-resolves .name here — not guaranteed.
      // Better: Query occasion table or pass display value from UI.
      appliedOccasionGr.occasion_text =
        appliedOccasionGr.occasion.name.toString();
      const recognitionOccasionSysId = appliedOccasionGr.insert();

      // Add logs for recipient creation failure
      if (!recognitionOccasionSysId) {
        errorMessage = appliedOccasionGr.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition occasion creation step. Error: ' +
          errorMessage
        );
      }
    });

    return {
      status: 'success',
      message: 'Recognition created successfully.',
    };
  },


  getRecognitionsForFeed: function (feedType, limit, offset, filters) {
    gs.info('User: ' + gs.getUserDisplayName() + '. RecognitionDAO.getRecognitionsForFeed called with feedType: ' + feedType + ', limit: ' + limit + ', offset: ' + offset + ', filters: ' + JSON.stringify(filters));

    limit = limit || 15;
    offset = offset || 0;

    const recognitions = [];

    const grRecognitions = new GlideRecordSecure(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognitions.orderByDesc('sys_created_on');
    grRecognitions.setLimit(limit);

    this._applyFilter(grRecognitions, feedType, filters);

    grRecognitions.chooseWindow(offset, offset + limit);
    grRecognitions.query();

    gs.info('User: ' + gs.getUserDisplayName() + '. Encoded Query: ' + grRecognitions.getEncodedQuery());

    while (grRecognitions.next()) {

      const recognition = this._getRecognitionObject(grRecognitions, feedType);
      // Add recognitions to list
      recognitions.push(recognition);
    }

    return recognitions;
  },

  getRecognitionById: function (recognitionId) {
    let recognition = {};

    const grRecognition = new GlideRecord('x_1794402_peerce_0_peer_recognition');
    if (grRecognition.get(recognitionId)) {
      recognition = this._getRecognitionObject(grRecognition, '');
    }

    return recognition;
  },


  _getRecognitionObject: function (grRecognition, feedType) {
    const recognitionSysId = grRecognition.getUniqueValue();
    const recognitionSender = grRecognition.getValue('sender');
    const isTeam = grRecognition.getValue('is_team') == '1';
    const isPrivate = grRecognition.getValue('is_private') == '1';

    const recognition = {
      senderId: recognitionSender,
      senderDisplay: grRecognition.getDisplayValue('sender'),
      isPrivate: isPrivate,
      isTeam: isTeam,
      message: grRecognition.getValue('message'),
      createdOn: grRecognition.getValue('sys_created_on'),
      recipients: [],
      recipientIds: [],
      occasions: [],
      feed: feedType,
      id: recognitionSysId,
      senderImageId: grRecognition.getElement('sender.photo').getValue(),
      reactions: [],
      comments: [],
      currentUserHasReacted: false
    };

    const recognitionData = this.getRecognitionRecipients(
      recognitionSysId,
      recognition.isTeam
    );

    recognition.recipients = recognitionData.displayNames;
    recognition.recipientIds = recognitionData.userIds;


    // Get recognition occasions
    recognition.occasions =
      this.getRecognitionOccasions(recognitionSysId);

    // Get recognition reactions
    const reactionData = this.getRecognitionReactions(recognitionSysId);
    recognition.reactions = reactionData.reactions;
    recognition.currentUserHasReacted = reactionData.currentUserHasReacted;

    recognition.comments = this.getRecognitionComments(recognitionSysId);

    return recognition;
  },


  getRecognitionDetails: function (userId) {
    // Store the original user ID to prevent side effects
    const originalUserId = this.currentUserId;

    try {
      // Temporarily set the currentUserId to the selected user
      this.currentUserId = userId;

      const filters = { sortOrder: 'newest' };
      const limit = 5;
      const offset = 0;

      const recognitions = this.getRecognitionsForFeed('you', limit, offset, filters);

      const recognitionDetails = [];

      recognitions.forEach(rec => {
        if (rec.isTeam) return;

        const isSent = (rec.senderId === userId);

        recognitionDetails.push({
          type: isSent ? 'Sent' : 'Received',
          recipientNames: isSent ? rec.recipients.join(', ') : '',
          senderName: isSent ? '' : rec.senderDisplay,
          message: rec.message,
          timestamp: rec.createdOn,
          occasions: rec.occasions
        });
      });

      return recognitionDetails;
    } finally {
      // Restore the original user ID
      this.currentUserId = originalUserId;
    }
  },

  getRecognitionRecipients: function (recognitionSysId, isTeam) {
    var recipientData = {
      userIds: [],
      displayNames: [],
    };

    var grRecognitionRecipient = new GlideRecord(
      'x_1794402_peerce_0_recognition_recipient'
    );
    grRecognitionRecipient.addQuery('recognition', recognitionSysId);
    // grRecognitionRecipient.order
    grRecognitionRecipient.query();

    while (grRecognitionRecipient.next()) {
      var recipientId = grRecognitionRecipient.getValue('recipient_user');
      var recipientDisplay =
        grRecognitionRecipient.getDisplayValue('recipient_user');

      if (isTeam) {
        recipientId =
          grRecognitionRecipient.getValue('recipient_group');
        recipientDisplay =
          grRecognitionRecipient.getDisplayValue('recipient_group');
      }

      recipientData.userIds.push(recipientId);
      recipientData.displayNames.push(recipientDisplay);
    }

    return recipientData;
  },

  getRecognitionOccasions: function (recognitionSysId) {
    const occasions = [];
    const grAppliedOccasion = new GlideRecord(
      'x_1794402_peerce_0_applied_recognition_occasion'
    );
    grAppliedOccasion.addQuery('recognition', recognitionSysId);
    grAppliedOccasion.query();

    while (grAppliedOccasion.next()) {
      occasions.push(grAppliedOccasion.getValue('occasion_text'));
    }

    return occasions;
  },

  _applyFilter: function (grRecognitions, feedType, filters) {
    // apply sorting order
    if (filters.sortOrder === 'oldest') {
      grRecognitions.orderBy('sys_created_on');
    } else {
      grRecognitions.orderByDesc('sys_created_on');
    }

    // apply feed filters
    switch (feedType) {
      case 'you': {
        if (filters.activity === 'sent') {
          grRecognitions.addQuery('sender', this.currentUserId);
          break;
        }

        const receivedIds = this._getRecognitionIdsForRecipients(
          this.currentUserId
        );

        if (filters.activity === 'received') {
          grRecognitions.addQuery('sys_id', 'IN', receivedIds);
        } else {
          grRecognitions
            .addQuery('sender', this.currentUserId)
            .addOrCondition('sys_id', 'IN', receivedIds);
        }

        break;
      }

      case 'team': {
        let userTeam = this.utils.getUserTeam();

        if (
          !userTeam ||
          !userTeam.combined ||
          !userTeam.combined.length
        ) {
          userTeam = {
            userGroups: [],
            teamMembers: [this.currentUserId],
            combined: [this.currentUserId],
          };
        }

        const teamReceivedIds = this._getRecognitionIdsForRecipients(
          userTeam.teamMembers, userTeam.userGroups
        );

        grRecognitions
          .addQuery('sender', 'IN', userTeam.teamMembers)
          .addOrCondition('sys_id', 'IN', teamReceivedIds);

        break;
      }

      case 'all':
        // Include only public recognitions
        const mainQuery = grRecognitions.addQuery('is_private', false);

        // Except those sent by the current user
        mainQuery.addOrCondition('sender', this.currentUserId);

        // Or where the current user is in the notify_to list
        mainQuery.addOrCondition('notify_to', 'CONTAINS', this.currentUserId);

        // Get current user's groups
        const myGroups = this.utils.getUserGroups(this.currentUserId);

        // Get all recognition sys_id's where user is Direct Recipient OR Group Recipient
        const myRelatedRecognitions = this._getRecognitionIdsForRecipients(this.currentUserId, myGroups);

        if (myRelatedRecognitions.length > 0) {
          mainQuery.addOrCondition('sys_id', 'IN', myRelatedRecognitions);
        }

        break;

      default:
        grRecognitions.addQuery('sys_id', '-1');
    }

    // 3. Layer on Additional AND Filters (Refinements)
    if (filters.timeframe && filters.timeframe !== 'all') {
      grRecognitions.addQuery(
        'sys_created_on',
        '>=',
        gs.daysAgo(filters.timeframe)
      );
    }

    if (filters.occasions && filters.occasions.length > 0) {
      const occasionRecognitionIds = this._getRecognitionIdsForOccasions(
        filters.occasions
      );

      // Ensure query doesn't fail if no occasions match
      if (occasionRecognitionIds.length > 0) {
        grRecognitions.addQuery('sys_id', 'IN', occasionRecognitionIds);
      } else {
        grRecognitions.addQuery('sys_id', '-1');
      }
    }

    // Skip the next set of filter if the current feed is you
    if (feedType === 'you') return;

    // Consolidate team/team member users and add the conditions
    let allUserIds = [], allGroupIds = [];

    if (filters.teamMember && filters.teamMember.length > 0) {
      allUserIds = allUserIds.concat(filters.teamMember);
    }

    if (filters.team && filters.team.length > 0) {
      const groupMembers = this.utils.getGroupMembers(filters.team);
      allUserIds = allUserIds.concat(groupMembers);

      allGroupIds = filters.team;
    }

    if (allUserIds.length > 0 || allGroupIds.length > 0) {
      const uniqueUserIds = Array.from(new Set(allUserIds));


      const recipientRecognitionIds = this._getRecognitionIdsForRecipients(uniqueUserIds, allGroupIds);

      grRecognitions
        .addQuery('sender', 'IN', uniqueUserIds)
        .addOrCondition('sys_id', 'IN', recipientRecognitionIds);
    }
  },


  getGraphData: function (occasionIds = [], daysAgo = 0) {
    const userNodes = new Map();
    const edgeCounts = new Map();
    const outDegreeMap = new Map(); // senderId → Set(recipientIds)
    const inDegreeMap = new Map();  // recipientId → Set(senderIds)
    const edges = [];

    // Helper function to create a new node if it doesn't exist
    const ensureNodeExists = (userId, userName) => {
      if (!userNodes.has(userId)) {
        userNodes.set(userId, {
          id: userId,
          label: userName,
          sent: 0,
          received: 0,
          value: 0,
          initials: this.utils.getInitials(userName),
          outDegree: 0,
          inDegree: 0,
        });
      }
    };

    // Query recognition recipients with necessary filters to build nodes and edges
    const recipientGr = new GlideRecordSecure('x_1794402_peerce_0_recognition_recipient');

    if (daysAgo > 0)
      recipientGr.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

    if (Array.isArray(occasionIds) && occasionIds.length > 0) {
      const validRecognitionIds = this._getRecognitionIdsForOccasions(occasionIds);
      recipientGr.addQuery('recognition', 'IN', validRecognitionIds);
    }

    recipientGr.addQuery('recognition.is_team', false);
    recipientGr.addNotNullQuery('recognition.sender');
    recipientGr.addNotNullQuery('recipient_user');
    recipientGr.query();

    while (recipientGr.next()) {
      const senderId = recipientGr.getElement('recognition.sender').getValue();
      const recipientId = recipientGr.getValue('recipient_user');

      if (senderId === recipientId) continue;

      const senderName = recipientGr.getDisplayValue('recognition.sender');
      const recipientName = recipientGr.getDisplayValue('recipient_user');

      // Add nodes if they don't exist
      ensureNodeExists(senderId, senderName);
      ensureNodeExists(recipientId, recipientName);

      const senderNode = userNodes.get(senderId);
      senderNode.sent += 1;
      senderNode.value += 1;

      const recipientNode = userNodes.get(recipientId);
      recipientNode.received += 1;
      recipientNode.value += 1;

      // Build edges, connting sender to recipient
      const key = senderId + '->' + recipientId;
      edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);

      // Build degree maps, count unique connections
      if (!outDegreeMap.has(senderId)) outDegreeMap.set(senderId, new Set());
      if (!inDegreeMap.has(recipientId)) inDegreeMap.set(recipientId, new Set());
      outDegreeMap.get(senderId).add(recipientId);
      inDegreeMap.get(recipientId).add(senderId);
    }

    // If no records were found, return an empty graph
    if (userNodes.size === 0) {
      return { nodes: [], edges: [], groups: [] };
    }

    // Add additional user details (department, photo) to nodes
    const userIds = Array.from(userNodes.keys());
    const uniqueGroups = new Set();
    const grUser = new GlideRecord('sys_user');
    grUser.addQuery('sys_id', 'IN', userIds);
    grUser.query();

    while (grUser.next()) {
      const userId = grUser.getUniqueValue();
      const node = userNodes.get(userId);
      if (node) {
        const department = grUser.getDisplayValue('department') || 'N/A';
        const photo = grUser.getValue('photo');
        node.group = department;
        node.userImage = photo ? 'sys_attachment.do?sys_id=' + photo : '';
        uniqueGroups.add(department);
      }
    }

    // Format edges in the required format with reciprocal info
    const allEdgeKeys = new Set(edgeCounts.keys());
    for (const [key, value] of edgeCounts.entries()) {
      const [fromId, toId] = key.split('->');
      edges.push({
        id: key, from: fromId, to: toId, value: value,
        title: `${value} recognition${value > 1 ? 's' : ''}.`,
        reciprocal: allEdgeKeys.has(toId + '->' + fromId)
      });
    }

    const finalNodes = Array.from(userNodes.values());
    finalNodes.forEach(node => {
      node.outDegree = outDegreeMap.has(node.id) ? outDegreeMap.get(node.id).size : 0;
      node.inDegree = inDegreeMap.has(node.id) ? inDegreeMap.get(node.id).size : 0;
    });

    // Sort and finalize groups
    const sortedGroups = Array.from(uniqueGroups).sort((a, b) => {
      if (a === 'N/A') return 1;
      if (b === 'N/A') return -1;
      return a.localeCompare(b);
    });

    return { nodes: finalNodes, edges: edges, groups: sortedGroups };
  },

  _getRecognitionIdsForOccasions: function (occasionIds) {
    if (typeof occasionIds === 'string') {
      occasionIds = [occasionIds];
    }

    if (!Array.isArray(occasionIds) || occasionIds.length === 0) {
      return [];
    }

    const recognitionIds = [];

    var gaAppliedOccasion = new GlideAggregate('x_1794402_peerce_0_applied_recognition_occasion');
    gaAppliedOccasion.addQuery('occasion', 'IN', occasionIds);
    gaAppliedOccasion.groupBy('recognition');
    gaAppliedOccasion.query();

    while (gaAppliedOccasion.next()) {
      recognitionIds.push(gaAppliedOccasion.getValue('recognition'));
    }

    return recognitionIds;
  },

  _getRecognitionIdsForRecipients: function (userIds, groupIds) {
    if (typeof userIds === 'string') {
      userIds = [userIds];
    }

    const hasUsers = Array.isArray(userIds) && userIds.length > 0;
    const hasGroups = Array.isArray(groupIds) && groupIds.length > 0;

    if (!hasUsers && !hasGroups) {
      return [];
    }

    var recognitionIds = [];

    var gaRecognitionRecipients = new GlideAggregate(
      'x_1794402_peerce_0_recognition_recipient'
    );

    gaRecognitionRecipients.addQuery('recipient_user', 'IN', userIds)
      .addOrCondition('recipient_group', 'IN', groupIds);

    gaRecognitionRecipients.query();

    while (gaRecognitionRecipients.next()) {
      recognitionIds.push(
        gaRecognitionRecipients.getValue('recognition')
      );
    }

    return recognitionIds;
  },


  // CRUD methods for Recognition Interactions

  // Toggles a 'like' interaction for a given recognition.
  toggleRecognitionReaction: function (recognitionId, userId) {
    if (!recognitionId || !userId) {
      return false;
    }

    const interactionGR = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    interactionGR.addQuery('recognition', recognitionId);
    interactionGR.addQuery('user', userId);
    interactionGR.addQuery('type', 'reaction');
    interactionGR.addQuery('reaction', 'like');
    interactionGR.setLimit(1);
    interactionGR.query();

    if (interactionGR.next()) {
      // Delete existing like reaction - unlike action
      return interactionGR.deleteRecord();
    }


    // If no existing like reaction, exists add one
    interactionGR.newRecord();
    interactionGR.setValue('recognition', recognitionId);
    interactionGR.setValue('user', userId);
    interactionGR.setValue('type', 'reaction');
    interactionGR.setValue('reaction', 'like');

    var interactionSysId = interactionGR.insert();

    return interactionSysId !== null;
  },

  getRecognitionReactions: function (recognitionId) {

    const reactions = [];
    let currentUserHasReacted = false;

    const interactionGR = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    interactionGR.addQuery('recognition', recognitionId);
    interactionGR.addQuery('type', 'reaction');
    interactionGR.addQuery('reaction', 'like');
    interactionGR.orderBy('sys_created_on');
    interactionGR.query();

    while (interactionGR.next()) {
      const reactionUserId = interactionGR.getValue('user');

      reactions.push({
        userId: reactionUserId,
        userName: interactionGR.getDisplayValue('user'),
        created: interactionGR.getValue('sys_created_on')
      });

      if (reactionUserId == this.currentUserId)
        currentUserHasReacted = true;

    }

    return { reactions, currentUserHasReacted };
  },

  addRecognitionComment: function (recognitionId, commentText, userId) {
    if (!recognitionId || !commentText || !userId) {
      gs.error('InteractionDAO.createComment: Missing required parameters.');
      return null;
    }

    const grInteractionComment = new GlideRecord('x_1794402_peerce_0_rec_interaction');

    grInteractionComment.newRecord();
    grInteractionComment.setValue('recognition', recognitionId);
    grInteractionComment.setValue('user', userId);
    grInteractionComment.setValue('type', 'comment');
    grInteractionComment.setValue('comment', commentText);

    var newCommentId = grInteractionComment.insert();

    if (!newCommentId) {
      gs.error('RecognitionDAO.addRecognitionComment: Failed to insert comment for recognition ' + recognitionId);
      return null;
    }

    return {
      id: newCommentId,
      text: grInteractionComment.getValue('comment'),
      authorName: grInteractionComment.getDisplayValue('user'),
      authorImage: grInteractionComment.getElement('user.photo').getValue(),
      userId: userId,
      created: grInteractionComment.getValue('sys_created_on'),
      likeCount: 0
    };
  },

  // Toggles a 'like' interaction for a given comment.
  toggleCommentReaction: function (parentCommentId, userId, recognitionId) {
    if (!parentCommentId || !userId) {
      return false;
    }

    const grCommentReaction = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    grCommentReaction.addQuery('parent', parentCommentId);
    grCommentReaction.addQuery('user', userId);
    grCommentReaction.addQuery('type', 'reaction');
    grCommentReaction.addQuery('reaction', 'like');
    grCommentReaction.setLimit(1);
    grCommentReaction.query();

    if (grCommentReaction.next()) {
      // Delete existing like reaction - unlike action
      return grCommentReaction.deleteRecord();
    }


    // If no existing like reaction, exists add one
    grCommentReaction.newRecord();
    grCommentReaction.setValue('parent', parentCommentId);
    grCommentReaction.setValue('user', userId);
    grCommentReaction.setValue('type', 'reaction');
    grCommentReaction.setValue('reaction', 'like');
    grCommentReaction.setValue('recognition', recognitionId);

    var interactionSysId = grCommentReaction.insert();

    return interactionSysId !== null;
  },

  getRecognitionComments: function (recognitionId) {
    const commentsMap = new Map();

    const grInteractionComments = new GlideRecord('x_1794402_peerce_0_rec_interaction');

    grInteractionComments.addQuery('recognition', recognitionId);
    grInteractionComments.addQuery('type', 'comment');
    grInteractionComments.orderBy('sys_created_on');
    grInteractionComments.query();

    while (grInteractionComments.next()) {
      const commentId = grInteractionComments.getValue('sys_id');

      commentsMap.set(commentId, {
        id: grInteractionComments.getValue('sys_id'),
        text: grInteractionComments.getValue('comment'),
        authorName: grInteractionComments.getDisplayValue('user'),
        userId: grInteractionComments.getValue('user'),
        authorImage: grInteractionComments.getElement('user.photo').getValue(),
        created: grInteractionComments.getValue('sys_created_on'),
        recognitionId: grInteractionComments.getValue('recognition'),

        currentUserHasReacted: false,
        likeCount: 0,
        likedByNames: []
      });
    }

    // If there're no comments, return early
    if (commentsMap.size === 0) {
      return [];
    }

    // Get all reactions for the fetched comments
    const commentIds = Array.from(commentsMap.keys());
    const grCommentReactions = new GlideRecord('x_1794402_peerce_0_rec_interaction');
    grCommentReactions.addQuery('parent', 'IN', commentIds);
    grCommentReactions.addQuery('type', 'reaction');
    grCommentReactions.query();

    while (grCommentReactions.next()) {
      const parentId = grCommentReactions.getValue('parent');

      const comment = commentsMap.get(parentId);
      if (!comment) continue;

      // Increase the like count for this comment
      comment.likeCount++;

      // Get this user's display name
      const userName = grCommentReactions.getDisplayValue('user');
      if (userName)
        comment.likedByNames.push(userName);

      // Check if this is the current user's reaction
      if (grCommentReactions.getValue('user') == this.currentUserId)
        comment.currentUserHasReacted = true;
    }

    return Array.from(commentsMap.values());
  },

  type: 'RecognitionDAO',
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-23 11:20:40</sys_created_on>
        <sys_id>afe03b9dc3e3225075ea722ed40131ea</sys_id>
        <sys_mod_count>159</sys_mod_count>
        <sys_name>RecognitionDAO</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sys_script_include_afe03b9dc3e3225075ea722ed40131ea</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-11-25 03:40:02</sys_updated_on>
    </sys_script_include>
</record_update>
