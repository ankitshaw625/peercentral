<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_1794402_peerce_0.RecognitionDAO</api_name>
        <caller_access>1</caller_access>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>RecognitionDAO</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * Data Access Object for the Recognition application.
 * Contains modular CRUD methods for both Recognition and Recipient tables,
 * as well as high-level service methods to coordinate them.
 */
var RecognitionDAO = Class.create();
RecognitionDAO.prototype = {
  initialize: function () {
    this.utils = new x_1794402_peerce_0.RecognitionUtils();
    this.currentUserId = gs.getUserID();
  },

  // =======================================================================
  // == Public callable methods
  // =======================================================================

  /**
   * Creates a complete recognition with its recipient(s).
   * @param {object} recognitionData - e.g., { recipient_id: '...', recipient_type: 'user', category_id: '...', message: '...' }
   * @returns {string} The sys_id of the new recognition record.
   */
  createRecognition: function (recognitionData) {
    recognitionData.sender = this.currentUserId;

    var isTeam = recognitionData.isTeam;
    var isPrivate = recognitionData.isPrivate;
    var recognitionSysId = null;

    // Insert a new recognition record
    var grRecognition = new GlideRecord(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognition.newRecord();
    // grRecognition.category = recognitionData.category;

    grRecognition.message = recognitionData.message;
    grRecognition.sender = recognitionData.sender;
    grRecognition.is_team = isTeam;
    grRecognition.is_private = isPrivate;
    grRecognition.notify_to = recognitionData.notifyTo;

    recognitionSysId = grRecognition.insert();

    // Handle error for recognition creation failure
    if (!recognitionSysId) {
      var errorMessage = grRecognition.getLastErrorMessage();

      gs.error(
        'RecognitionDAO: createRecognition failed at recognition creation step. Error: ' +
        errorMessage
      );

      return {
        status: 'failure',
        message: errorMessage,
      };
    }

    var recipients = recognitionData.recipients.split(',');

    for (var i = 0; i < recipients.length; i++) {
      var currentRecipient = recipients[i];

      // Create individual recipients
      var recognitionRecipientSysId = null;
      var grRecognitionRecipient = new GlideRecord(
        'x_1794402_peerce_0_recognition_recipient'
      );

      grRecognitionRecipient.newRecord();
      grRecognitionRecipient.recognition = recognitionSysId;

      if (isTeam) {
        grRecognitionRecipient.recipient_group = currentRecipient;
      } else {
        grRecognitionRecipient.recipient_user = currentRecipient;
      }

      recognitionRecipientSysId = grRecognitionRecipient.insert();

      // Add logs for recipient creation failure
      if (!recognitionRecipientSysId) {
        errorMessage = grRecognitionRecipient.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition recipient creation step. Error: ' +
          errorMessage
        );
      }
    }

    const occasions = recognitionData.category.split(',');

    occasions.forEach((occ) => {
      const appliedOccasionGr = new GlideRecord(
        'x_1794402_peerce_0_applied_recognition_occasion'
      );
      appliedOccasionGr.newRecord();
      appliedOccasionGr.recognition = recognitionSysId;
      appliedOccasionGr.occasion = occ;
      // ⚠️ HACK: ServiceNow sometimes auto-resolves .name here — not guaranteed.
      // Better: Query occasion table or pass display value from UI.
      appliedOccasionGr.occasion_text =
        appliedOccasionGr.occasion.name.toString();
      const recognitionOccasionSysId = appliedOccasionGr.insert();

      // Add logs for recipient creation failure
      if (!recognitionOccasionSysId) {
        errorMessage = appliedOccasionGr.getLastErrorMessage();

        gs.error(
          'RecognitionDAO: createRecognition failed at recognition occasion creation step. Error: ' +
          errorMessage
        );
      }
    });

    return {
      status: 'success',
      message: 'Recognition created successfully.',
    };
  },

  /**
   * Retrieves a  list of recognition records, including their recipients.
   * @param {number} limit - The number of recognition records to retrieve.
   * @returns {Array<object>} A complete data object for the recognition, or empty array.
   */

  getRecognitionsForFeed: function (feedType, limit, offset, filters) {
    limit = limit || 15;
    offset = offset || 0;

    const recognitions = [];

    const grRecognitions = new GlideRecordSecure(
      'x_1794402_peerce_0_peer_recognition'
    );
    grRecognitions.orderByDesc('sys_created_on');
    grRecognitions.setLimit(limit);

    this._applyFilter(grRecognitions, feedType, filters);

    grRecognitions.chooseWindow(offset, offset + limit);
    grRecognitions.query();

    // gs.info('Query: ' + grRecognitions.getEncodedQuery());

    while (grRecognitions.next()) {
      const recognitionSysId = grRecognitions.getUniqueValue();
      const recognitionSender = grRecognitions.getValue('sender');
      const isTeam = grRecognitions.getValue('is_team') == '1';
      const isPrivate = grRecognitions.getValue('is_private') == '1';

      const recognition = {
        senderId: recognitionSender,
        senderDisplay: grRecognitions.getDisplayValue('sender'),
        isPrivate: isPrivate,
        isTeam: isTeam,
        message: grRecognitions.getValue('message'),
        createdOn: grRecognitions.getValue('sys_created_on'),
        recipients: [],
        occasions: [],
        feed: feedType,
        id: recognitionSysId,
        senderImageId: grRecognitions.getElement('sender.photo').getValue(),
      };

      const recognitionData = this.getRecognitionRecipients(
        recognitionSysId,
        recognition.isTeam
      );

      recognition.recipients = recognitionData.displayNames;

      // // Privacy filter (if not fully handled by ACLs)
      // if (isPrivate && !this.utils.canReadPrivateRecognition(grRecognitions, this.currentUserId)) {
      //     continue;
      // }

      // const recognitionRecipients = recognitionData.userIds;

      // var isCurrentUserRecognition = this.currentUserId == recognitionSender || recognitionRecipients.includes(this.currentUserId);

      // recognition.feed = isCurrentUserRecognition ? 'you' : 'all';

      // if (this.utils.isTeamRecognition(recognitionSender, recognitionRecipients)) {
      //     recognition.feed += ',team';
      // }

      // Get recognition occasions
      recognition.occasions =
        this.getRecognitionOccasions(recognitionSysId);

      // Add recognitions to list
      recognitions.push(recognition);
    }

    return recognitions;
  },

  getRecognitionDetails: function (userId) {
    // Store the original user ID to prevent side effects
    const originalUserId = this.currentUserId;

    try {
      // Temporarily set the currentUserId to the selected user
      this.currentUserId = userId;

      const filters = { sortOrder: 'newest' };
      const limit = 5;
      const offset = 0;

      const recognitions = this.getRecognitionsForFeed('you', limit, offset, filters);

      const recognitionDetails = [];

      recognitions.forEach(rec => {
        if (rec.isTeam) return;

        const isSent = (rec.senderId === userId);

        recognitionDetails.push({
          type: isSent ? 'Sent' : 'Received',
          recipientNames: isSent ? rec.recipients.join(', ') : '',
          senderName: isSent ? '' : rec.senderDisplay,
          message: rec.message,
          timestamp: rec.createdOn,
          occasions: rec.occasions
        });
      });

      return recognitionDetails;
    } finally {
      // Restore the original user ID
      this.currentUserId = originalUserId;
    }
  },

  getRecognitionRecipients: function (recognitionSysId, isTeam) {
    var recipientData = {
      userIds: [],
      displayNames: [],
    };

    var grRecognitionRecipient = new GlideRecord(
      'x_1794402_peerce_0_recognition_recipient'
    );
    grRecognitionRecipient.addQuery('recognition', recognitionSysId);
    // grRecognitionRecipient.order
    grRecognitionRecipient.query();

    while (grRecognitionRecipient.next()) {
      var recipientId = grRecognitionRecipient.getValue('recipient_user');
      var recipientDisplay =
        grRecognitionRecipient.getDisplayValue('recipient_user');

      if (isTeam) {
        recipientId =
          grRecognitionRecipient.getValue('recipient_group');
        recipientDisplay =
          grRecognitionRecipient.getDisplayValue('recipient_group');
      }

      recipientData.userIds.push(recipientId);
      recipientData.displayNames.push(recipientDisplay);
    }

    return recipientData;
  },

  getRecognitionOccasions: function (recognitionSysId) {
    const occasions = [];
    const grAppliedOccasion = new GlideRecord(
      'x_1794402_peerce_0_applied_recognition_occasion'
    );
    grAppliedOccasion.addQuery('recognition', recognitionSysId);
    grAppliedOccasion.query();

    while (grAppliedOccasion.next()) {
      occasions.push(grAppliedOccasion.getValue('occasion_text'));
    }

    return occasions;
  },

  _applyFilter: function (grRecognitions, feedType, filters) {
    // apply sorting order
    if (filters.sortOrder === 'oldest') {
      grRecognitions.orderBy('sys_created_on');
    } else {
      grRecognitions.orderByDesc('sys_created_on');
    }

    // apply feed filters
    switch (feedType) {
      case 'you': {
        if (filters.activity === 'sent') {
          grRecognitions.addQuery('sender', this.currentUserId);
          break;
        }

        const receivedIds = this._getRecognitionIdsForRecipients(
          this.currentUserId
        );

        if (filters.activity === 'received') {
          grRecognitions.addQuery('sys_id', 'IN', receivedIds);
        } else {
          grRecognitions
            .addQuery('sender', this.currentUserId)
            .addOrCondition('sys_id', 'IN', receivedIds);
        }

        break;
      }

      case 'team': {
        let userTeam = this.utils.getUserTeam();

        if (
          !userTeam ||
          !userTeam.combined ||
          !userTeam.combined.length
        ) {
          userTeam = {
            userGroups: [],
            teamMembers: [this.currentUserId],
            combined: [this.currentUserId],
          };
        }

        const teamReceivedIds = this._getRecognitionIdsForRecipients(
          userTeam.teamMembers, userTeam.userGroups
        );

        grRecognitions
          .addQuery('sender', 'IN', userTeam.teamMembers)
          .addOrCondition('sys_id', 'IN', teamReceivedIds);
        break;
      }

      case 'all':
        break;

      default:
        grRecognitions.addQuery('sys_id', '-1');
    }

    // 3. Layer on Additional AND Filters (Refinements)
    if (filters.timeframe && filters.timeframe !== 'all') {
      grRecognitions.addQuery(
        'sys_created_on',
        '>=',
        gs.daysAgo(filters.timeframe)
      );
    }

    if (filters.occasions && filters.occasions.length > 0) {
      const occasionRecognitionIds = this._getRecognitionIdsForOccasions(
        filters.occasions
      );

      // Ensure query doesn't fail if no occasions match
      if (occasionRecognitionIds.length > 0) {
        grRecognitions.addQuery('sys_id', 'IN', occasionRecognitionIds);
      } else {
        grRecognitions.addQuery('sys_id', '-1');
      }
    }

    // Skip the next set of filter if the current feed is you
    if (feedType === 'you') return;

    // Consolidate team/team member users and add the conditions
    let allUserIds = [], allGroupIds = [];

    if (filters.teamMember && filters.teamMember.length > 0) {
      allUserIds = allUserIds.concat(filters.teamMember);
    }

    if (filters.team && filters.team.length > 0) {
      const groupMembers = this.utils.getGroupMembers(filters.team);
      allUserIds = allUserIds.concat(groupMembers);

      allGroupIds = filters.team;
    }

    if (allUserIds.length > 0 || allGroupIds.length > 0) {
      const uniqueUserIds = Array.from(new Set(allUserIds));


      const recipientRecognitionIds = this._getRecognitionIdsForRecipients(uniqueUserIds, allGroupIds);

      grRecognitions
        .addQuery('sender', 'IN', uniqueUserIds)
        .addOrCondition('sys_id', 'IN', recipientRecognitionIds);
    }
  },


  // getGraphData: function (occasionIds = [], daysAgo = 0) {
  //   let validRecognitionIds = [];

  //   if (Array.isArray(occasionIds) && occasionIds.length > 0) {
  //     validRecognitionIds = this._getRecognitionIdsForOccasions(occasionIds);
  //   }

  //   const userNodes = new Map();
  //   let edges = [];

  //   // Get all users who sent recognitions as nodes
  //   const sentAgg = new GlideAggregate('x_1794402_peerce_0_recognition_recipient');

  //   if (daysAgo > 0)
  //     sentAgg.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

  //   if (validRecognitionIds.length > 0)
  //     sentAgg.addQuery('recognition', 'IN', validRecognitionIds);

  //   sentAgg.addQuery('recognition.is_team', false);
  //   sentAgg.addNotNullQuery('recognition.sender');
  //   sentAgg.addAggregate('COUNT');
  //   sentAgg.groupBy('recognition.sender');
  //   sentAgg.query();

  //   while (sentAgg.next()) {
  //     const senderId = sentAgg.getValue('recognition.sender');

  //     const count = parseInt(sentAgg.getAggregate('COUNT'), 10);

  //     const senderName = sentAgg.getDisplayValue('recognition.sender');

  //     userNodes.set(senderId, {
  //       id: senderId,
  //       label: senderName,
  //       sent: count,
  //       received: 0,
  //       value: 0,
  //       initials: this.utils.getInitials(senderName)
  //     });
  //   }

  //   // Get all users who received recognitions as nodes
  //   const receivedAgg = new GlideAggregate('x_1794402_peerce_0_recognition_recipient');

  //   if (daysAgo > 0)
  //     receivedAgg.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

  //   if (validRecognitionIds.length > 0)
  //     receivedAgg.addQuery('recognition', 'IN', validRecognitionIds);

  //   receivedAgg.addQuery('recognition.is_team', false);
  //   receivedAgg.addNotNullQuery('recipient_user');
  //   receivedAgg.addAggregate('COUNT');
  //   receivedAgg.groupBy('recipient_user');
  //   receivedAgg.query();

  //   while (receivedAgg.next()) {
  //     const recipientId = receivedAgg.getValue('recipient_user');

  //     const count = parseInt(receivedAgg.getAggregate('COUNT'), 10);

  //     if (userNodes.has(recipientId)) {
  //       const existingNode = userNodes.get(recipientId);
  //       existingNode.received = count;
  //       existingNode.value = existingNode.sent + count;

  //       continue;
  //     }

  //     const recipientName = receivedAgg.getDisplayValue('recipient_user');

  //     userNodes.set(recipientId, {
  //       id: recipientId,
  //       label: recipientName,
  //       sent: 0,
  //       received: count,
  //       value: count,
  //       initials: this.utils.getInitials(recipientName)
  //     });
  //   }


  //   // Get all the edges with counts
  //   const edgeCounts = new Map();
  //   const outDegreeMap = new Map(); // senderId → Set(recipientIds)
  //   const inDegreeMap = new Map();  // recipientId → Set(senderIds)
  //   const recipientGr = new GlideRecordSecure('x_1794402_peerce_0_recognition_recipient');

  //   if (daysAgo > 0)
  //     recipientGr.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

  //   if (validRecognitionIds.length > 0)
  //     recipientGr.addQuery('recognition', 'IN', validRecognitionIds);


  //   recipientGr.addQuery('recognition.is_team', false);
  //   recipientGr.addNotNullQuery('recognition.sender');
  //   recipientGr.addNotNullQuery('recipient_user');
  //   recipientGr.query();

  //   while (recipientGr.next()) {
  //     const senderId = recipientGr.getElement('recognition.sender').getValue();
  //     const recipientId = recipientGr.getValue('recipient_user');

  //     if (senderId === recipientId) continue;

  //     // if (senderId !== recipientId) {
  //     const key = senderId + '->' + recipientId;
  //     // const currentCount = edgeCounts.get(key) || 0;
  //     edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);
  //     // }

  //     // Track node degrees
  //     if (!outDegreeMap.has(senderId)) outDegreeMap.set(senderId, new Set());
  //     if (!inDegreeMap.has(recipientId)) inDegreeMap.set(recipientId, new Set());

  //     outDegreeMap.get(senderId).add(recipientId);
  //     inDegreeMap.get(recipientId).add(senderId);
  //   }

  //   const uniqueGroups = new Set();
  //   const userIds = Array.from(userNodes.keys());

  //   if (userIds.length > 0) {
  //     const grUser = new GlideRecord('sys_user');
  //     grUser.addQuery('sys_id', 'IN', userIds);
  //     grUser.query();

  //     while (grUser.next()) {
  //       const userId = grUser.getUniqueValue();
  //       const photo = grUser.getValue('photo');
  //       const department = grUser.getDisplayValue('department') || 'N/A';

  //       // Directly get the node from the userNodes map
  //       const node = userNodes.get(userId);

  //       if (node) {
  //         // Update the node object directly with the fetched details
  //         node.group = department;
  //         node.userImage = photo ? 'sys_attachment.do?sys_id=' + photo : '';

  //         uniqueGroups.add(department);
  //       }
  //     }
  //   }

  //   const allEdgeKeys = new Set(edgeCounts.keys());

  //   // Convert the edges into the required format
  //   for (const [key, value] of edgeCounts.entries()) {
  //     const [fromId, toId] = key.split('->');

  //     const reverseKey = toId + '->' + fromId;
  //     const reciprocal = allEdgeKeys.has(reverseKey);

  //     const title = value === 1
  //       ? value + ' recognition.'
  //       : value + ' recognitions.';

  //     edges.push({
  //       id: key,
  //       from: fromId,
  //       to: toId,
  //       value: value,
  //       title: title,
  //       reciprocal: reciprocal
  //     });
  //   }

  //   // Get all the computed notes with statistics
  //   const nodes = Array.from(userNodes.values());

  //   // Add the degrees for the nodes
  //   nodes.forEach(node => {
  //     const uniqueSent = outDegreeMap.get(node.id);
  //     const uniqueReceived = inDegreeMap.get(node.id);

  //     node.outDegree = uniqueSent ? uniqueSent.size : 0;
  //     node.inDegree = uniqueReceived ? uniqueReceived.size : 0;
  //   });

  //   const sortedGroups = Array.from(uniqueGroups).sort((a, b) => {
  //     // Handle the special 'N/A' case.
  //     if (a === 'N/A') return 1;  // Move 'a' to the end if it's 'N/A'
  //     if (b === 'N/A') return -1; // Move 'b' to the end if it's 'N/A'

  //     // For all other cases, use the standard alphabetical sort.
  //     return a.localeCompare(b);
  //   });

  //   // Return the final data object
  //   return {
  //     nodes: nodes,
  //     edges: edges,
  //     groups: sortedGroups
  //   };
  // },


  getGraphData: function (occasionIds = [], daysAgo = 0) {
    const userNodes = new Map();
    const edgeCounts = new Map();
    const outDegreeMap = new Map(); // senderId → Set(recipientIds)
    const inDegreeMap = new Map();  // recipientId → Set(senderIds)
    const edges = [];

    // Helper function to create a new node if it doesn't exist
    const ensureNodeExists = (userId, userName) => {
      if (!userNodes.has(userId)) {
        userNodes.set(userId, {
          id: userId,
          label: userName,
          sent: 0,
          received: 0,
          value: 0,
          initials: this.utils.getInitials(userName),
          outDegree: 0,
          inDegree: 0,
        });
      }
    };

    // Query recognition recipients with necessary filters to build nodes and edges
    const recipientGr = new GlideRecordSecure('x_1794402_peerce_0_recognition_recipient');

    if (daysAgo > 0)
      recipientGr.addQuery('sys_created_on', '>=', gs.daysAgo(daysAgo));

    if (Array.isArray(occasionIds) && occasionIds.length > 0) {
      const validRecognitionIds = this._getRecognitionIdsForOccasions(occasionIds);
      recipientGr.addQuery('recognition', 'IN', validRecognitionIds);
    }

    recipientGr.addQuery('recognition.is_team', false);
    recipientGr.addNotNullQuery('recognition.sender');
    recipientGr.addNotNullQuery('recipient_user');
    recipientGr.query();

    while (recipientGr.next()) {
      const senderId = recipientGr.getElement('recognition.sender').getValue();
      const recipientId = recipientGr.getValue('recipient_user');

      if (senderId === recipientId) continue;

      const senderName = recipientGr.getDisplayValue('recognition.sender');
      const recipientName = recipientGr.getDisplayValue('recipient_user');

      // Add nodes if they don't exist
      ensureNodeExists(senderId, senderName);
      ensureNodeExists(recipientId, recipientName);

      const senderNode = userNodes.get(senderId);
      senderNode.sent += 1;
      senderNode.value += 1;

      const recipientNode = userNodes.get(recipientId);
      recipientNode.received += 1;
      recipientNode.value += 1;

      // Build edges, connting sender to recipient
      const key = senderId + '->' + recipientId;
      edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);

      // Build degree maps, count unique connections
      if (!outDegreeMap.has(senderId)) outDegreeMap.set(senderId, new Set());
      if (!inDegreeMap.has(recipientId)) inDegreeMap.set(recipientId, new Set());
      outDegreeMap.get(senderId).add(recipientId);
      inDegreeMap.get(recipientId).add(senderId);
    }

    // If no records were found, return an empty graph
    if (userNodes.size === 0) {
      return { nodes: [], edges: [], groups: [] };
    }

    // Add additional user details (department, photo) to nodes
    const userIds = Array.from(userNodes.keys());
    const uniqueGroups = new Set();
    const grUser = new GlideRecord('sys_user');
    grUser.addQuery('sys_id', 'IN', userIds);
    grUser.query();

    while (grUser.next()) {
      const userId = grUser.getUniqueValue();
      const node = userNodes.get(userId);
      if (node) {
        const department = grUser.getDisplayValue('department') || 'N/A';
        const photo = grUser.getValue('photo');
        node.group = department;
        node.userImage = photo ? 'sys_attachment.do?sys_id=' + photo : '';
        uniqueGroups.add(department);
      }
    }

    // Format edges in the required format with reciprocal info
    const allEdgeKeys = new Set(edgeCounts.keys());
    for (const [key, value] of edgeCounts.entries()) {
      const [fromId, toId] = key.split('->');
      edges.push({
        id: key, from: fromId, to: toId, value: value,
        title: `${value} recognition${value > 1 ? 's' : ''}.`,
        reciprocal: allEdgeKeys.has(toId + '->' + fromId)
      });
    }

    const finalNodes = Array.from(userNodes.values());
    finalNodes.forEach(node => {
      node.outDegree = outDegreeMap.has(node.id) ? outDegreeMap.get(node.id).size : 0;
      node.inDegree = inDegreeMap.has(node.id) ? inDegreeMap.get(node.id).size : 0;
    });

    // Sort and finalize groups
    const sortedGroups = Array.from(uniqueGroups).sort((a, b) => {
      if (a === 'N/A') return 1;
      if (b === 'N/A') return -1;
      return a.localeCompare(b);
    });

    return { nodes: finalNodes, edges: edges, groups: sortedGroups };
  },

  _getRecognitionIdsForOccasions: function (occasionIds) {
    if (typeof occasionIds === 'string') {
      occasionIds = [occasionIds];
    }

    if (!Array.isArray(occasionIds) || occasionIds.length === 0) {
      return [];
    }

    const recognitionIds = [];

    var gaAppliedOccasion = new GlideAggregate('x_1794402_peerce_0_applied_recognition_occasion');
    gaAppliedOccasion.addQuery('occasion', 'IN', occasionIds);
    gaAppliedOccasion.groupBy('recognition');
    gaAppliedOccasion.query();

    while (gaAppliedOccasion.next()) {
      recognitionIds.push(gaAppliedOccasion.getValue('recognition'));
    }

    return recognitionIds;
  },

  _getRecognitionIdsForRecipients: function (userIds, groupIds) {
    if (typeof userIds === 'string') {
      userIds = [userIds];
    }

    const hasUsers = Array.isArray(userIds) && userIds.length > 0;
    const hasGroups = Array.isArray(groupIds) && groupIds.length > 0;

    if (!hasUsers && !hasGroups) {
      return [];
    }

    var recognitionIds = [];

    var gaRecognitionRecipients = new GlideAggregate(
      'x_1794402_peerce_0_recognition_recipient'
    );

    gaRecognitionRecipients.addQuery('recipient_user', 'IN', userIds)
      .addOrCondition('recipient_group', 'IN', groupIds);

    gaRecognitionRecipients.query();

    while (gaRecognitionRecipients.next()) {
      recognitionIds.push(
        gaRecognitionRecipients.getValue('recognition')
      );
    }

    return recognitionIds;
  },

  // /**
  //  * Retrieves a complete recognition record, including its recipients.
  //  * @param {string} sysId - The sys_id of the recognition to retrieve.
  //  * @returns {object} A complete data object for the recognition, or null.
  //  */
  // getCompleteRecognition: function(sysId) {
  //     var recognition = this._readRecognition(sysId);
  //     if (!recognition)
  //         return null;

  //     recognition.recipients = this._readRecipientsForRecognition(sysId);
  //     return recognition;
  // },

  // /**
  //  * Deletes a complete recognition and its associated recipients.
  //  * @param {string} sysId - The sys_id of the recognition to delete.
  //  * @returns {boolean} True on success.
  //  */
  // deleteCompleteRecognition: function(sysId) {
  //     this._deleteRecipientsForRecognition(sysId);
  //     return this._deleteRecognition(sysId);
  // },

  // // =======================================================================
  // // == Private Helper Methods
  // // =======================================================================

  // _createRecognition: function(data) {

  // },

  // _readRecognition: function(sysId) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (!recGr.get(sysId))
  //         return null;

  //     return {
  //         sys_id: recGr.getUniqueValue(),
  //         message: recGr.getValue('message'),
  //         sender: recGr.getDisplayValue('sender'),
  //         category: recGr.getDisplayValue('category'),
  //         created_on: recGr.getValue('sys_created_on')
  //     };
  // },

  // _updateRecognition: function(sysId, data) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (!recGr.get(sysId))
  //         return false;

  //     for (var key in data) {
  //         if (recGr.isValidField(key))
  //             recGr.setValue(key, data[key]);
  //     }
  //     return recGr.update();
  // },

  // _deleteRecognition: function(sysId) {
  //     var recGr = new GlideRecord(this.recognitionTable);
  //     if (recGr.get(sysId))
  //         return recGr.deleteRecord();
  //     return false;
  // },

  // // =======================================================================
  // // == LOW-LEVEL RECIPIENT METHODS (Private)
  // // =======================================================================

  // _readRecipientsForRecognition: function(recognitionSysId) {
  //     var recipients = [];
  //     var recGr = new GlideRecord(this.recipientTable);
  //     recGr.addQuery('recognition', recognitionSysId);
  //     recGr.query();
  //     while (recGr.next()) {
  //         var name = recGr.getDisplayValue('recipient_user') || recGr.getDisplayValue('recipient_group');
  //         recipients.push({
  //             name: name,
  //             sys_id: recGr.getUniqueValue()
  //         });
  //     }
  //     return recipients;
  // },

  // _deleteRecipientsForRecognition: function(recognitionSysId) {
  //     var recGr = new GlideRecord(this.recipientTable);
  //     recGr.addQuery('recognition', recognitionSysId);
  //     recGr.deleteMultiple();
  // },

  type: 'RecognitionDAO',
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-23 11:20:40</sys_created_on>
        <sys_id>afe03b9dc3e3225075ea722ed40131ea</sys_id>
        <sys_mod_count>118</sys_mod_count>
        <sys_name>RecognitionDAO</sys_name>
        <sys_package display_value="PeerCentral" source="x_1794402_peerce_0">b7f1c56ac397621075ea722ed40131d0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="PeerCentral">b7f1c56ac397621075ea722ed40131d0</sys_scope>
        <sys_update_name>sys_script_include_afe03b9dc3e3225075ea722ed40131ea</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-03 18:08:47</sys_updated_on>
    </sys_script_include>
</record_update>
